#### 1. 停机迁移方案

 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个**导数的一次性工具**，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。

导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。

![database-shard-method-1](https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/database-shard-method-1.png)



#### 2. 双写迁移方案

简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，**除了对老库增删改，都加上对新库的增删改**，这就是所谓的**双写**，同时写俩库，老库和新库。

然后**系统部署**之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是**不允许用老数据覆盖新数据**。

导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。

接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。

![database-shard-method-2](https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/database-shard-method-2.png)



#### 3. 双写迁移方案(二)

上面的方法有一个硬伤，我们需要在原有的业务逻辑中加入写入新库的逻辑。

大家想一下，这么做，是不是造成了严重的代码入侵。将非业务代码嵌入业务代码，这么做，后期删代码的时候特别累。

有没什么方法，可以避免这个问题的?

有的，**订阅 binlog 日志**。

记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。binlog不会记录SELECT和SHOW这类操作，因为这类操作对据本身并没有修改。

还记得我们在 双写部署法(一) 里介绍的，往消息队列里发的消息，都是写操作的消息。而 binlog 日志记录的也是写操作。所以订阅该日志，也能满足我们的需求。