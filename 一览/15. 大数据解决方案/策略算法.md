#### 1. 分治策略

1. 分而治之，进行哈希取余；
2. 对每个子文件进行 HashSet 统计。

基本处理大数据第一直觉就是分而治之



#### 2. 前缀树

1. 利用字符串的公共前缀来降低存储成本，提高查询效率。

适用场景：

- 如何从大量的 URL 中找出相同的 URL？
- 如何查询最热门的查询串？



#### 3. 大顶堆/小顶堆/双顶堆

一般用于求topN

适用场景：

- 如何从大量数据中找出高频词？
- 如何找出某一天访问百度网站最多的 IP？



#### 4. 位图法

**位图**，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。

假设我们要对 `[0,7]` 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：

```
0 0 0 0 0 0 0 0Copy to clipboardErrorCopied
```

然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：

```
0 0 0 0 1 0 1 0Copy to clipboardErrorCopied
```

依次遍历，结束后，位数组是这样的：

```
0 1 1 0 1 1 1 0Copy to clipboardErrorCopied
```

每个为 1 的位，它的下标都表示了一个数：

```
for i in range(8):
    if bits[i] == 1:
        print(i)Copy to clipboardErrorCopied
```

这样我们其实就已经实现了排序。

对于整数相关的算法的求解，**位图法**是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。

**判断数字是否重复的问题**，位图法是一种非常高效的方法，当然前提是：内存要满足位图法所需要的存储空间。



适用场景：

- 如何在大量的数据中找出不重复的整数？
- 如何在大量的数据中判断一个数是否存在？