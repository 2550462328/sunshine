在上述的本地消息表方案中，生产者需要额外创建消息表，还需要对本地消息表进行轮询，业务负担较重。阿里开源的RocketMQ 4.3之后的版本正式支持事务消息，该事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题。



**事务消息发送及提交：**

1. 发送消息（half消息）

2. 服务端存储消息，并响应消息的写入结果

3. 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）

4. 根据本地事务状态执行Commit或者Rollback（Commit操作发布消息，消息对消费者可见）



**正常发送的流程图如下：**

![img](http://pcc.huitogo.club/9eecac7f500c558838b0c0220ac4c944)



**实际解决方案的流程如下：**

![distributed-transaction-reliable-message](https://doocs.gitee.io/advanced-java/docs/distributed-system/images/distributed-transaction-reliable-message.png)

大概的意思就是：

1. A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；
2. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；
3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
4. mq 会自动**定时轮询**所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。
5. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。



**补偿流程：**

对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”Producer收到回查消息，返回消息对应的本地事务的状态，为Commit或者Rollback事务消息方案与本地消息表机制非常类似，区别主要在于原先相关的本地表操作替换成了一个反查接口



**事务消息特点如下：**

长事务仅需要分拆成多个任务，并提供一个反查接口，使用简单

消费者的逻辑如果无法通过重试成功，那么还需要更多的机制，来回滚操作



**适用场景：**

适用于可异步执行的业务，且后续操作无需回滚的业务



这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你就用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。

