**Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务**

金融核心等业务可能会选择 TCC 方案，以追求强一致性和更高的并发量，而对于更多的金融核心以上的业务系统 往往会选择补偿事务，补偿事务处理在 30 多年前就提出了 Saga 理论，随着微服务的发展，近些年才逐步受到大家的关注。目前业界比较公认的是采用 Saga 作为长事务的解决方案。



#### 1. 基本原理

业务流程中每个参与者都提交本地事务，若某一个参与者失败，则补偿前面已经成功的参与者。下图左侧是正常的事务流程，当执行到 T3 时发生了错误，则开始执行右边的事务补偿流程，反向执行 T3、T2、T1 的补偿服务 C3、C2、C1，将 T3、T2、T1 已经修改的数据补偿掉。

![distributed-transacion-TCC](https://doocs.gitee.io/advanced-java/docs/distributed-system/images/distributed-transaction-saga.png)



#### 2. 使用方式

##### 2.1 事件/编排Choreography

事件/编排Choreography：没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。

该实现第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件，当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。



处理流程说明：

1. 订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。
2. 支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。
3. 库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。
4. 货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT。
5. 最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。



假设库存服务在事务过程中失败了。进行回滚：

库存服务产生PRODUCT_OUT_OF_STOCK_EVENT

订购服务和支付服务会监听到上面库存服务的这一事件：

1. 支付服务会退款给客户。
2. 订单服务将订单状态设置为失败。



优点：事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，因为他们彼此之间没有直接的耦合。如果您的事务涉及2至4个步骤，则可能是非常合适的。



##### 2.2 命令/协调orchestrator

命令/协调orchestrator：中央协调器负责集中处理事件的决策和业务逻辑排序。

saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉他们应该执行哪些操作。



处理流程说明：

1. 订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。
2. OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息。
3. OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息。
4. OSO向货运服务发送订单发货命令，货运服务将回复Order Delivered消息。



OSO订单Saga协调器必须事先知道执行“创建订单”事务所需的流程(通过读取BPM业务流程XML配置获得)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。当你有一个中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。



优点：

1. 避免服务之间的循环依赖关系，因为saga协调器会调用saga参与者，但参与者不会调用协调器。
2. 集中分布式事务的编排。
3. 只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
4. 在添加新步骤时，事务复杂性保持线性，回滚更容易管理。
5. 如果在第一笔交易还没有执行完，想改变有第二笔事务的目标对象，则可以轻松地将其暂停在协调器上，直到第一笔交易结束。



#### 3. 使用场景

对于一致性要求高、短流程、并发高 的场景，如：金融核心系统，会优先考虑 TCC 方案。而在另外一些场景下，我们并不需要这么强的一致性，只需要保证最终一致性即可。

比如 很多金融核心以上的业务（渠道层、产品层、系统集成层），这些系统的特点是最终一致即可、流程多、流程长、还可能要调用其它公司的服务。这种情况如果选择 TCC 方案开发的话，一来成本高，二来无法要求其它公司的服务也遵循 TCC 模式。同时流程长，事务边界太长，加锁时间长，也会影响并发性能。



所以 Saga 模式的适用场景是：

- 业务流程长、业务流程多；

- 参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口。

  

#### 4. 优势

- 一阶段提交本地事务，无锁，高性能；

- 参与者可异步执行，高吞吐；

- 补偿服务易于实现，因为一个更新操作的反向操作是比较容易理解的。

  

#### 5. 缺点

- 不保证事务的隔离性。
- 需要定义正常操作以及补偿操作，开发量比XA大
- 一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况