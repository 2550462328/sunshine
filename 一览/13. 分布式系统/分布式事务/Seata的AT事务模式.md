这是阿里开源项目seata中的一种事务模式，在蚂蚁金服也被称为FMT。优点是该事务模式使用方式，类似XA模式，业务无需编写各类补偿操作，回滚由框架自动完成，缺点也类似AT，存在较长时间的锁，不满足高并发的场景。有兴趣的同学可以参考seata-AT模式。

![img](http://pcc.huitogo.club/0b7db83761c50fadf1e1674b4c496de9)



一阶段：TM开启全局事务、TM调用分支、RM注册分支事务、RM记录undolog日志、RM提交事务、TCC记录各分支状态。

二阶段：TM通知提交/回滚全局事务、TC检查各分支事务状态，成功，则删除undolog日志，失败，则根据undolog日志回滚。

![img](http://pcc.huitogo.club/252df686cdbabd1e1503ca7e2f52b00d)



解决：引入全局锁，在A事务提交事务释放DB锁之前，申请全局锁，而此时如果B事务进行操作修改，在执行更新数据库操作前会获取全局锁，获取失败，则无法更新，不断重试，但不能一直让其重试，否则A尝试获取B占用的DB锁则会造成死锁，一般让其重试30秒，然后失败则放弃其占有的DB锁，执行失败。A锁此时就能获取DB锁，执行回滚，然后再释放全局锁。

![img](http://pcc.huitogo.club/e32d0c46e8b5fe5ba303eae911beed83)



又引来新问题：如果是另一个不归seata管理的事务的？全局锁失败！



XA也自动带来了解决的方案：

```
首先记录更新前的记录

记录更新后的记录。
```



完整正确的执行流程如下：

```
原数据假设为100，undolog记录100这个数值。

A事务获取DB锁将数据修改为90，此时undolog记录这条90。

A事务获取全局锁，并提交事务释放DB数据库锁

A事务回滚，在回滚为100前，会比较此时数据是否是90。假设，不归Seata管理的B事务，不需要获取全局锁，然后成功获取DB锁并修改了数据为80，则此时A事务将90（A修改后）与80（B修改）比较，则回滚失败。
```



**Seata的四种事务优缺点介绍**

- XA：强一致性，无代码侵入、但一阶段事务不提交、会锁住资源，导致性能低。需要依赖数据库的事务特性。
- AT：默认，弱一致性，无代码侵入，一阶段事务直接提交，失败则根据undolog日志回滚，隔离性引入全局锁，但并发几率低，所以性能会比XA好。
- TCC：无需依赖关系型数据库，基于资源预留隔离。try、confirm、canel需要人工手写，而且需要考虑空悬挂、空回滚、幂等性判断，较为复杂、性能最好，但成本太高。
- Seaga:适用于长事务类型，无太多应用场景。

![img](http://pcc.huitogo.club/367fbb12416b5b8630111ec4bb50b0a5)