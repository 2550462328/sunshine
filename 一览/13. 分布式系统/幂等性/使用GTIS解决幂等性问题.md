所谓幂等，简单地说，就是对接口的多次调用所产生的结果和调用一次是一致的。扩展一下，这里的接口，可以理解为对外发布的HTTP接口或者Thrift接口，也可以是接收消息的内部接口，甚至是一个内部方法或操作。

在分布式环境中，网络环境更加复杂，因前端操作抖动、网络故障、消息重复、响应速度慢等原因，对接口的重复调用概率会比集中式环境下更大，尤其是重复消息在分布式环境中很难避免。



GTIS就是这样的一个解决方案。它是一个轻量的重复操作关卡系统，它能够确保在分布式环境中操作的唯一性。我们可以用它来间接保证每个操作的幂等性。它具有如下特点：

- 高效：低延时，单个方法平均响应时间在2ms内，几乎不会对业务造成影响；
- 可靠：提供降级策略，以应对外部存储引擎故障所造成的影响；提供应用鉴权，提供集群配置自定义，降低不同业务之间的干扰；
- 简单：接入简捷方便，学习成本低。只需简单的配置，在代码中进行两个方法的调用即可完成所有的接入工作；
- 灵活：提供多种接口参数、使用策略，以满足不同的业务需求。



#### 1．实现原理

##### 1.1 基本原理

GTIS的实现思路是将每一个不同的业务操作赋予其唯一性。这个唯一性是通过对不同操作所对应的唯一的内容特性生成一个唯一的全局ID来实现的。基本原则为：相同的操作生成相同的全局ID；不同的操作生成不同的全局ID。



生成的全局ID需要存储在外部存储引擎中，数据库、Redis亦或是Tair等均可实现。考虑到Tair天生分布式和持久化的优势，目前的GTIS存储在Tair中。其相应的key和value如下：

key：将对于不同的业务，采用APP_KEY+业务操作内容特性生成一个唯一标识trans_contents。然后对唯一标识进行加密生成全局ID作为Key。

value：current_timestamp + trans_contents，current_timestamp用于标识当前的操作线程。



判断是否重复，主要利用Tair的SETNX方法，如果原来没有值则set且返回成功，如果已经有值则返回失败。



##### 1.2 内部流程

GTIS的内部实现流程为：

1. 业务方在业务操作之前，生成一个能够唯一标识该操作的transContents，传入GTIS；
2. GTIS根据传入的transContents，用MD5生成全局ID；
3.  GTIS将全局ID作为key，current_timestamp+transContents作为value放入Tair进行setNx，将结果返回给业务方；
4. 业务方根据返回结果确定能否开始进行业务操作；
5. 若能，开始进行操作；若不能，则结束当前操作；
6. 业务方将操作结果和请求结果传入GTIS，系统进行一次请求结果的检验；
7. 若该次操作成功，GTIS根据key取出value值，跟传入的返回结果进行比对，如果两者相等，则将该全局ID的过期时间改为较长时间；
8. GTIS返回最终结果

![img](http://pcc.huitogo.club/5c415b85c24fb32d8af73c6873eefa61)