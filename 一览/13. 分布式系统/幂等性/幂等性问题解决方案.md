#### 1. 建唯一索引

唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增异常时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。



#### 2. 悲观锁

select for update，整个执行过程中锁定该订单对应的记录。

```
select id ,name from table_# where id='##' for update;
```



悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用（另外还要考虑id是否为主键，如果id不是主键或者不是 InnoDB 存储引擎，那么就会出现锁全表）。

注意：这种在DB读大于写的情况下尽量少用。



#### 3. 乐观锁

给数据库表增加一个version字段，可以通过这个字段来判断是否已经被修改了。

```
update table_xxx set name=#name#,version=version+1 where version=#version#
```



#### 4. 先查询后修改数据

面对并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。



注意：核心高并发流程不要用这种方法。



#### 5. 状态机幂等

在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。



#### 6. token机制

防止页面重复提交：

- 集群环境：采用token加redis（redis单线程的，处理需要排队）
- 单JVM环境：采用token加redis或token加jvm内存



数据提交前要向服务的申请token，token放到redis或jvm内存，设置token有效时间，提交后后台校验token，同时删除token，生成新的token返回。token特点：要申请，一次有效性，可以限流。



#### 7. 全局唯一ID

如果使用全局唯一ID，就是根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、redis等。如果存在则表示该方法已经执行。