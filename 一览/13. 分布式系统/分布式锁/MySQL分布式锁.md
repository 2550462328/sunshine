对于分布式锁我们可以创建一个锁表:

![img](http://pcc.huitogo.club/9e07b64c6b62e182e9128186f4bab262)



前面我们所说的lock(),trylock(long timeout)，trylock()这几个方法可以用下面的伪代码实现。

#### 1. lock

![img](http://pcc.huitogo.club/8fe3dc2d729ca44798f21cc445462fe5)



mysqlLock.lcok内部是一个sql,为了达到可重入锁的效果那么我们应该先进行查询，如果有值，那么需要比较node_info是否一致，这里的node_info可以用机器IP和线程名字来表示，如果一致那么就加可重入锁count的值，如果不一致那么就返回false。如果没有值那么直接插入一条数据。



伪代码如下:

![img](http://pcc.huitogo.club/8a56eba5912eed6b95a6791b8f9b3cb4)



需要注意的是这一段代码需要加事务，必须要保证这一系列操作的原子性。



select ... for update使用的是mysql的悲观锁（行锁），与之相对应的就是乐观锁。



在我们实际项目中也是经常实现乐观锁，因为我们加行锁的性能消耗比较大，通常我们会对于一些竞争不是那么激烈，但是其又需要保证我们并发的顺序执行使用乐观锁进行处理，我们可以对我们的表加一个版本号字段，那么我们查询出来一个版本号之后，update或者delete的时候需要依赖我们查询出来的版本号，判断当前数据库和查询出来的版本号是否相等，如果相等那么就可以执行，如果不等那么就不能执行。这样的一个策略很像我们的CAS(Compare And Swap),比较并交换是一个原子操作。这样我们就能避免加select * for update行锁的开销。



#### 2. tryLock

tryLock()是非阻塞获取锁，如果获取不到那么就会马上返回，代码可以如下:

![img](http://pcc.huitogo.club/f1c06cb68ec17e3be86ce4eee5d1bb0f)





#### 3. tryLock(long timeout)

实现如下:

![img](http://pcc.huitogo.club/ff8ab90d2d42818fb0761cbe6261b73b)



#### 4. unlock

unlock的话如果这里的count为1那么可以删除，如果大于1那么需要减去1。

![img](http://pcc.huitogo.club/0e2616497ed1537002a3db91522619ae)



我们有可能会遇到我们的机器节点挂了，那么这个锁就不会得到释放，我们可以**启动一个定时任务**，通过计算一般我们处理任务的一般的时间，比如是5ms，那么我们可以稍微扩大一点，当这个锁超过20ms没有被释放我们就可以认定是节点挂了然后将其直接释放。



#### 5. 总结

1. 适用场景: Mysql分布式锁一般适用于资源不存在数据库，如果数据库存在比如订单，那么可以直接对这条数据加行锁，不需要我们上面多的繁琐的步骤，比如一个订单，那么我们可以用select * from order_table where id = 'xxx' for update进行加行锁，那么其他的事务就不能对其进行修改。
2. 优点：理解起来简单，不需要维护额外的第三方中间件(比如Redis,Zk)。
3. 缺点：虽然容易理解但是实现起来较为繁琐，需要自己考虑锁超时，加事务等等。性能局限于数据库，一般对比缓存来说性能较低。对于高并发的场景并不是很适合。