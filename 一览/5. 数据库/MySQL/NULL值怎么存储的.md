对于InnoDB存储引擎来说，记录都是存储在页面中的（一个页面默认是16KB大小），这些页面可以作为B+树的节点而组成一个索引，类似这种样子：

![img](http://pcc.huitogo.club/9380881f5b683394c2cf14c2f21a1376)



聚簇索引和二级索引都对应着像上图一样的B+树（也就是说有多少个索引就有多少棵对应的B+树），不过：

1. 对于聚簇索引来说，B+树每一层节点（页面）都是按照页中记录的主键值大小进行排序的；而对于二级索引来说，B+树每一层节点（页面）都是按照页中记录的给定的索引列的值进行排序的。
2. 对于聚簇索引来说，B+树叶子节点对应的页面中存储的是完整的用户记录（就是一条记录中包含我们定义的所有列值，还包含一些InnoDB自己添加的一些隐藏列）；而对于二级索引来说，B+树叶子节点对应的页面中存储的只是索引列的值 + 主键值。



那么首先对于主键（聚簇索引）来说，肯定不会有NULL值的



如果你执行这样的语句

```
// 不会执行的语句

1. SELECT * FROM tbl_name WHERE primary_key IS NULL; 
```



语句优化器自己就能判定出WHERE子句必定为NULL，所以压根儿不会去执行它



其次就是二级索引，索引列的值可能为NULL。那对于索引列值为NULL的二级索引记录来说，它们被放在B+树的哪里呢？

答案是：**放在B+树的最左边**。



比如我们对一个key做NULL值查询

![img](http://pcc.huitogo.club/5608e058f70b01b96e42ace4f62d3880)



值为NULL的二级索引记录都被放在了B+树的最左边，这是因为设计InnoDB的大牛有这样的规定：

```
1. We define the SQL null to be the smallest possible value of a field.
```



也就是说他们把SQL中的NULL值认为是列中最小的值。