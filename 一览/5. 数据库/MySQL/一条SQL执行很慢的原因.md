对于一条sql执行很慢的原因



#### **1. 偶尔很慢**

一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得这条SQL语句的书写本身是没什么问题的，而是其他原因导致的，那会是什么原因呢？

##### 1.1 数据库在刷新脏页（flush）

当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在内存中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在**通过 redo log 里的日记把最新的数据同步到磁盘中**去。



当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。



刷脏页有下面4种场景（后两种不用太关注“性能”问题）：

1）redolog写满了

redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，就会导致我们平时正常的SQL语句突然执行的很慢，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。



2）内存不够用

如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。



3）MySQL 认为系统“空闲”的时候

这时系统没什么压力



4）MySQL 正常关闭的时候

这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。



##### 1.2 正在获取锁

这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的表，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了。



如果要判断是否真的在等待锁，我们可以用 show processlist这个命令来查看当前的状态



#### 2. 一直很慢

##### 2.1 没有用索引

走全表扫描当然慢了



##### 2.2 索引没有用到

###### 2.2.1 由于自己疏忽没有用上索引



比如说

- like “%key%”查询操作

num + 1 = 1000，toDate(date) = ‘1990-01-01’等在条件左边计算的

- 组合索引最左匹配没有匹配上的

- 使用or连接条件语句的

- 使用子查询的

- 条件语句类型不匹配的，比如‘123’ = 123



等等复杂情况



###### 2.2.2 数据库自己误判的

我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是整行字段的数据，而非主键索引上存放的值不是整行字段的数据，而且存放主键字段的值。



假如我们有以下查询，c字段有非主键索引

```
 // 查询语句

1. select * from t where 100 < c and c < 100000; 
```



我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。

那如果发生数据库自己误判的情况下，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 < c and c < 100000 的数据。



**为什么会出现这种情况呢？**

系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。



如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c < and c < 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。



**所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么预测判断呢？**

系统是通过**索引的区分度**来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为**基数**，即**区分度越高，基数越大**。所以呢，基数越大，意味着符合 100 < c and c < 10000 这个条件的行数越少。



所以呢，**一个索引的基数越大，意味着走索引查询越有优势。**



**这个索引的基数怎么来的呢？**

系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过**采样**的方式，来预测索引的基数的。



扯了这么多，重点的来了，居然是采样，那就有可能出现失误的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。然后系统就不走 c 索引了，直接走全部扫描了。

所以呢，说了这么多，得出结论：**由于统计的失误，导致系统没有走索引，而是走了全表扫描**，而这，也是导致我们 SQL 语句执行的很慢的原因之一。

但是需要注意的是，**系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。**



我们有时候也可以通过强制走索引的方式来查询，例如

```
 // 查询语句

1. select * from t force index(a) where c < 100 and c < 100000; 
```



或者通过主动查询索引的基数

```
// 查询基数

1. show index from t; 
```



如果和实际差距过大可以手动重新统计分析

```
 // 重新分析

1. analyze table t; 
```



**既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦，这也可能是 SQL 执行的很慢的一个原因。**