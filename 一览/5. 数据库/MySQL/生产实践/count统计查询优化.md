#### 1. count的作用

COUNT()是一个特殊的函数，有**两种非常不同的作用**：

- **统计某个列值的数量**
- 统计行数**。**

在统计列值时要求列值非空的（不统计NULL）。如果在COUNT()的括号中指定了列或列的表达式，统计的就是这个表达式有值的结果数。

COUNT()的另外一个作用是统计结果集的行数。当mysql确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用COUNT(\*)的时候，这种情况下通配符*并不会像我们猜想的那样扩展成所有的列，**实际上，它会忽略所有的列而直接统计所有的行数。**

我们发现一个最常见的错误就是，在括号内指定了一个列却希望统计结果集的行数。如果希望知道的是结果集的行数，最好使用COUNT(*)，这样写意义清晰，性能也会很好。



#### 2. MyISAM的count(*)总是比InnoDB快吗？

一个容易产生的误解就是：MyISAM的COUNT()函数总是非常快，不过这是有前提条件的，即只有没有任何where条件的COUNT(\*)才非常快，因为此时无需实际地去计算表的行数。MySQL可以利用存储引擎的特性直接获得这个值。如果MySQL知道某列col不可能为NULL值，那么MySQL内部会将COUNT(col)表达式优化为COUNT(*)。

当统计带WHERE子句的结果集行数，可以是统计某个列值的数量时，MySQL的COUNT()和其它存储引擎没有任何不同，就不再有神话般的速度了。所以在MyISAM引擎表上执行COUNT()有时候比别的引擎快，有时候比别的引擎慢，这受很多因素影响，要视具体情况而定。



#### 3. Innodb存储引擎的count过程

1. innodb存储引擎的物理结构包含 **表空间、段、区、页、行** 五个层级，数据文件按照主键排序存储在页中（页在逻辑上连续），主键的位置即为数据存储位置。
2. **二级索引存储的数据为指定字段的值与主键值**。当我们通过二级索引统计数据的时候，无需扫描数据文件；而通过主键索引统计数据时，由于主键索引与数据文件存放在一起，所以每次都会扫描数据文件，故大多数情况下，通过二级索引**统计数据效率** >= 基于主键统计效率。
3. 由于二级索引存储的数据为指定字段的值与主键值，故在无索引覆盖的情况下，查询二级索引后会根据二级索引获取的主键到主键索引中提取数据，此过程可能造成大量的随机io，导致查询速度较慢。
4. 由于主键索引与数据存储保持一致，故基于主键的查找数据要比通过二级索引查询数据要快（**使用二级索引时，查询到的数据条数>总条数的20%时候mysql就选择全表扫描，但在主键索引上，即使符合条件的达到 90%依然会走索引**）。



#### 4. count慢的原因

innodb为聚簇索引同时支持事务，其在count指令实现上采用实时统计方式。在无可用的二级索引情况下，执行count会使MySQL扫描全表数据，当数据中存在大字段或字段较多时候，其效率非常低下（每个页只能包含较少的数据条数，需要访问的物理页较多）。



#### 5. Innodb可优化点

1. 主键需要采用占用空间尽量小的类型且数据具有连续性（推荐自增整形id），这样有利于减少页分裂、页内数据移动，可加快插入速度同时有利于增加二级索引密度（一个数据页上可以存储更多的数据）。
2. 在表包含大字段或字段较多情况下，若存在count统计需求，可建一个较小字段的二级索引（例 char(1) , tinyint )来进行count统计加速。