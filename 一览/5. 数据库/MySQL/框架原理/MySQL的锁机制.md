Mysql为了解决并发、数据安全的问题，使用了锁机制

#### 1. 表级锁、行级锁和页级锁

##### 1.1 表级锁

Mysql中锁定**粒度最大**的一种锁，对当前操作的整张表加锁，实现简单 ，**资源消耗也比较少，加锁快，不会出现死锁** 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。



##### 1.2 行级锁

Mysql中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 **行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁**。 InnoDB（默认）支持的行级锁，包括如下几种：

- **Record Lock**: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；
- **Gap Lock**: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
- **Next-key Lock**： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。



Innodb 的锁的策略为 **next-key 锁**，即 record lock + gap lock ，是通过在 index 上加 lock 实现的。

- 如果 index 为 unique index ，则降级为 record lock 行锁。
- 如果是普通 index ，则为 next-key lock 。
- 如果没有 index ，则直接锁住全表，即表锁。



***Q1：什么是幻读？***

这里纠正传统的对幻读的解释：

> 幻读错误的理解：说幻读是 事务A 执行两次 select 操作得到不同的数据集，即 select 1 得到 10 条记录，select 2 得到 11 条记录。这其实并不是幻读，这是不可重复读的一种，只会在 R-U R-C 级别下出现，而在 mysql 默认的 RR 隔离级别是不会出现的。



这里给出我对幻读的比较白话的理解：

> 幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。



这里我们以两个事务执行插入语句为例

> step1 T1: SELECT * FROM \`users\` WHERE \`id\` = 1;
> step2 T2: INSERT INTO \`users\` VALUES (1, 'big cat');
> step3 T1: INSERT INTO \`users\` VALUES (1, 'big cat');
> step4 T1: SELECT * FROM \`users\` WHERE \`id\` = 1;

- T1 ：主事务，检测表中是否有 id 为 1 的记录，没有则插入，这是我们期望的正常业务逻辑。
- T2 ：干扰事务，目的在于扰乱 T1 的正常的事务执行。



在 RR 隔离级别下，step1、step2 是会正常执行的，step3 则会报错主键冲突，对于 T1 的业务来说是执行失败的，这里 T1 就是发生了**幻读**，因为 T1 在 step1 中读取的数据状态并不能支撑后续的业务操作，T1：“见鬼了，我刚才读到的结果应该可以支持我这样操作才对啊，为什么现在不可以”。T1 不敢相信的又执行了 step4，发现和 setp1 读取的结果是一样的（RR下的 MMVC机制）。此时，幻读无疑已经发生，T1 无论读取多少次，都查不到 id = 1 的记录，但它的确无法插入这条他通过读取来认定不存在的记录（此数据已被T2插入），对于 T1 来说，它幻读了。



**怎么规避幻读？**

以RR隔离级别为例，在MVCC下肯定是无法避免，还是得加锁，加s锁还不行，得加x锁，则需要T1对`SELECT * FROM users WHERE id = 1;`手动加锁。



***Q2：为什么说Gap Lock可以解决幻读？***

即使我们给所有update涉及的行都加上了行锁，还是无法解决新插入的记录，因为这些记录原本不存在，自然无法加上行锁。

那怎么办呢？为了解决这个问题，innodb只好引入新的锁，间隙锁（Gap Lock）。

“间隙锁，锁的是两个值之间的空隙”。



举个例子：	

在四条记录，ID=0，10，20，30中，会产生如下的五个间隙范围

![img](http://pcc.huitogo.club/ce0105ba9e52cc36349bc67360541673)

间隙锁就是对这五个间隙范围加锁，防止新的记录插入。



注意，行锁的冲突是行与行之间的冲突，是行锁与行锁之间的。与间隙锁冲突的是往“间隙中插入数据”这个操作，间隙锁本身不会产生冲突。

还需要知道，即便当前记录不存在，比如 `id=1` 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的**行锁锁定的是索引**，故记录实体存在与否没关系，存在就加 `行X锁`，不存在就加 `next-key lock间隙X锁`），其他事务则无法插入此索引的记录，故杜绝了幻读。



***Q3：间隙锁不会产生什么问题吗？***

间隙锁的引入也带来了一些新的问题，比如：**降低并发度，可能导致死锁**。

因为间隙锁的引入，可能会导致同样的语句锁住了更大的范围。



那怎么办呢？

注意，间隙锁在可重复读级别下才是有效的。



所以，只要我们的业务不需要可重复读的保证，我们就可以把隔离级别设置为读提交（也是阿里云rds数据库的默认隔离级别），就没有间隙锁了。

然后，为了解决可能的数据和日志不一致的问题，需要把binlog格式设置为row。

**读提交级别 + binlog的row格式**，也是一般公司数据库的标准配置。



***Q4：行级锁什么时候释放？***

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是语句执行完了了就立刻释放， 而是要等到**事务结束时才释放**。



**怎么加行级锁？**

使用update语句自动加写锁，使用select语句需要加上for update。



***Q5：怎么优化行级锁？***

我们知道了，行锁必须在整个事务完全提交后才会释放，那么，如果我们的事物中需要锁住多行，就要把最可能造成锁冲突，或者是锁住最多行的语句尽可能地往后放。



举个例子，小A在线上购买了商家B的一个产品，这个购买的动作可以简化为3个操作：

1. 小A的银行账户余额扣款x;
2. 商家B的银行账户余额增加x;
3. 添加一条交易记录；

这里，涉及到两个update操作，和一个insert操作。为了保证交易的原子性，将三个动作放在了一个事务中。



那怎么安排三个语句的先后顺序呢？

显然，这里最容易造成冲突的是步骤2），可能同时有多个用户购买商家B的产品，然后需要给商家B的余额做update操作。

另外，步骤3）是insert操作，最不容易出现锁冲突。

所以，最好的步骤顺序是3）-> 1) -> 2)，将最容易产生冲突的操作放在最后执行，那么会比2）->1) ->3)的顺序，大大提高并发度。



***Q6：为什么不使用行级锁？***

虽然使用行级锁具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的：

事务更新大表中的大部分数据直接使用表级锁效率更高；

事务比较复杂，使用行级锁很可能引起死锁导致回滚。



##### 1.3 页级锁

MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁



#### 2. 排它锁和共享锁

##### 2.1 共享锁（S）

共享锁有如下特征：

1. 加锁与解锁：当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据。在默认情况下，数据被读取后，数据库系统立即解除共享锁。例如，当一个事务执行查询“SELECT * FROM accounts”语句时，数据库系统首先锁定第一行，读取之后，解除对第一行的锁定，然后锁定第二行。这样，在一个事务读操作过程中，允许b其他事务同时更新accounts表中未锁定的行。
2. 兼容性：如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。
3. 并发性能：具有良好的并发性能，当数据被放置共享锁后，还可以再放置共享锁或更新锁。所以并发性能很好。



##### 2.2 排它锁（X）

排它锁有如下特征：

1. 加锁与解锁：当一个事务执行insert、update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。如果该数据资源已经有其他锁（任何锁）存在时，就无法对其再放置独占锁了。
2. 兼容性：独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他的锁了。同样，如果数据资源上已经放置了其他锁，那么也就不能再放置独占锁了。
3. 并发性能：最差。只允许一个事务访问锁定的数据，如果其他事务也需要访问该数据，就必须等待。



##### 2.3 更新锁

更新锁在的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象。例如，对于以下的update语句：

```
UPDATE accounts SET balance=900 WHERE id=1
```

更新操作需要分两步：读取accounts表中id为1的记录 –> 执行更新操作。

如果在第一步使用共享锁，再第二步把锁升级为独占锁，就可能出现死锁现象。例如：两个事务都获取了同一数据资源的共享锁，然后都要把锁升级为独占锁，但需要等待另一个事务解除共享锁才能升级为独占锁，这就造成了死锁。



更新锁有如下特征：

1. 加锁与解锁：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。
2. 兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。这样，当多个事务更新相同的数据时，只有一个事务能获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取得更新锁，这就避免了死锁。
3. 并发性能：允许多个事务同时读锁定的资源，但不允许其他事务修改它



其中InnoDB的**锁机制兼容**情况如下：

![img](http://pcc.huitogo.club/3439c136777e5dd42578e7c47aebfa14)



#### 3. 悲观锁和乐观锁

乐观锁一般是指用户自己实现的一种锁机制，假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。乐观锁的实现方式一般包括使用版本号和时间戳。



悲观锁一般就是我们通常说的数据库锁机制，以下讨论都是基于悲观锁。

悲观锁主要表锁、行锁、页锁。在MyISAM中只用到表锁，不会有死锁的问题，锁的开销也很小，但是相应的并发能力很差。innodb实现了行级锁和表锁，锁的粒度变小了，并发能力变强，但是相应的锁的开销变大，很有可能出现死锁。同时inodb需要协调这两种锁，算法也变得复杂。InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

表锁和行锁都分为共享锁和排他锁（独占锁），而更新锁是为了解决行锁升级（共享锁升级为独占锁）的死锁问题。

innodb中表锁和行锁一起用，所以为了提高效率有了意向锁（意向共享锁和意向排他锁）。



知乎上有个解释十分形象，如下：

> 在mysql中有表锁，读锁锁表，会阻塞其他事务修改表数据。写锁锁表，会阻塞其他事务读和写。
>
> Innodb引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只读锁。排它锁，一个事务对一行的排他读写锁。
>
> 这两中类型的锁共存的问题考虑这个例子：事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。



数据库要怎么判断这个冲突呢？

1. step1：判断表是否已被其他事务用表锁锁表
2. step2：判断表中的每一行是否已被行锁锁住。

注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。



在意向锁存在的情况下，上面的判断可以改成

1. step1：不变
2. step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。



#### 4. 死锁

**那什么时候会出现死锁以及怎么避免死锁呢?**

InnoDB的**行级锁是基于索引实现的**，如果查询语句为命中任何索引，那么InnoDB会使用表级锁. 此外，InnoDB的行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突，还需要注意的是，在通过

```
1. SELECT ...LOCK IN SHARE MODE; 

2. 或 

3. SELECT ...FOR UPDATE; 
```



使用锁的时候，如果表没有定义任何索引，那么InnoDB会创建一个隐藏的聚簇索引并使用这个索引来加记录锁。

此外，不同于MyISAM总是一次性获得所需的全部锁，**InnoDB的锁是逐步获得的，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁**。 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务



我们可以采取以上方式避免死锁：

- 通过表级锁来减少死锁产生的概率；

- 设置获得锁的超时时间。

  > 通过超时，至少保证最差最差最差情况下，可以有退出的口子。

- 多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；

- 同一个事务尽可能做到一次锁定所需要的所有资源。

- 避免事务中的用户交互。

  - 使用低隔离级别。