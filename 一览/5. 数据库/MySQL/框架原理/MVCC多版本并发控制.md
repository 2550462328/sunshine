#### 1. 什么是MVCC呢？

<高性能MySQL>中对MVCC的部分介绍

> MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。
>
> 可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。
>
> MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。
>
> MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。



我们可以了解到

1. MVCC是被Mysql中 事务型存储引擎InnoDB 所支持的;
2. 应对高并发事务, MVCC比单纯的加锁更高效;
3. MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;
4. MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;
5. 各数据库中MVCC实现并不统一
6. InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的（有说三个的，第三个是基于聚簇索引下没有主键且也找不到一个唯一的非空列作为主键的情况下mysql自己新增的一个主键列DB_ROW_ID）



#### 2. 那在没有MVCC之前MYSQL是怎么实现事务性的呢？

在InnoDB存储引擎下**通过行锁**。



对于select操作，普通的select不会对行上锁，而select…lock in share mode会上共享锁，select…for update会上排它锁。

对于update/deletec操作，会自动上共享锁。

对于insert，会上间隙锁，用来解决幻读问题（在RR隔离级别下）。

![img](http://pcc.huitogo.club/2f27d565c054cd67a6d60cb15533d27d)



**在了解Mysql的InnoDB是怎么实现MVCC之前，我们先了解一些特称**

#### 3. 快照读和当前读

##### 3.1 当前读

当前读, 读取的是最新版本, 并且**对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题**，也叫“一致性锁定读”。

例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。

相应指令有：

> select ... lock in share mode
>
> select ... for update
>
> insert
>
> update
>
> delete



当前读的实现方式：**next-key锁(行记录锁+Gap间隙锁)**

**间隙锁：**只有在Read Repeatable、Serializable隔离级别才有，就是锁定范围空间的数据，假设id有3,4,5，锁定id>3的数据，是指的4，5及**后面的数字都会被锁定，**因为此时如果不锁定没有的数据，例如当加入了新的数据id=6，就会出现幻读，间隙锁避免了幻读。

1. 对主键或唯一索引，如果当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。
2. 没有索引的列，当前读操作时，会加全表gap锁，生产环境要注意。
3. 非唯一索引列，如果where条件部分命中(>、<、like等)或者全未命中，则会加附近Gap间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据。

![img](https://img2018.cnblogs.com/blog/1394267/201904/1394267-20190419210558267-1762386565.png)



##### 3.2 快照读

对于普通的select的读取方式，称为”**快照读**“，也叫”一致性非锁定读“。

1. Read Committed隔离级别：每次select都生成一个快照读。

2. Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。

快照读的实现方式：**undolog**和**多版本并发控制MVCC**



如果在update、insert的时候，不能进行select，那么服务的并发访问性能就太差了。因此，我们日常的查询，都是“快照读”，不会上锁，只有在update\insert\“当前读”的时候，才会上锁。而**为了解决“快照读”的并发访问问题**，就引入了MVCC。



#### 4. 快照snapshot（read view）

事务快照是PostgreSQL中snapshot的概念，在mysql中就是read view。



事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：

- 查看当前所有的未提交并活跃的事务，存储在数组中
- 选取未提交并活跃的事务中最小的XID，记录在快照的xmin中
- 选取所有已提交事务中最大的XID，加1后记录在xmax中



read view 主要是用来做可见性判断的, 比较普遍的解释便是"本事务不可见的当前其他活跃事务"，也叫“一致性视图”。



**为什么会有read view？**

因为MVCC面向的是多版本，所谓多版本，就是一行记录在数据库中存储了多个版本，每个版本以事务ID作为版本号。InnoDB 里面每个事务有一个唯一的事务 ID，是在事务开始的时候向InnoDB的事务系统申请的，并且按照申请顺序严格递增的。假如一行记录被多个事务更新，那么，就会产生多个版本的记录。



以某一行数据作为例子：

![img](http://pcc.huitogo.club/345af23d3f43939b8bec012215ece6f3)



经过两次事务的操作，value从22变成了19，同时，保留了三个事务id，15、25、30。



在每个记录多版本的基础上，需要利用“一致性视图”，来做版本的可见性判断。



**read view的生成时机**？

- “读未提及”级别下，没有一致性视图
- “读已提交”级别下，会在 **每个SQL开始执行的时候** 创建一致性视图
- “可重复读”级别下，会在 **每个事务开始的时候** 创建一致性视图
- “串行化”级别下，直接通过加锁避免并发问题



**read view 创建一致性视图的逻辑？**

以“可重复读”级别为例。

- 当一个事务开启的时候，会向系统申请一个新事务id
- 此时，可能还有多个正在进行的其他事务没有提交，因此在瞬时时刻，是有多个活跃的未提交事务id
- 将这些未提交的事务id组成一个数组，数组里面最小的事务id记录为低水位，当前系统创建过的事务id的最大值+1记录为高水位
- 这个数组array 和 高水位，就组成了“一致性视图”。



#### 5. undo-log

Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。



大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo



因此在undo-log中分为: **insert undo log** 和 **update undo log**

- insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。
- update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。



在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。
所以如果需要实时显示数据，还是需要通过加锁来实现。这个时候会使用next-key技术来实现。



#### 6. 每一行添加的两个隐藏字段

![img](https://img2018.cnblogs.com/blog/1394267/201905/1394267-20190519155117018-1175429688.png)

- 6字节的事务ID(DB_TRX_ID)字段： 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。

  至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。

- 7字节的回滚指针(DB_ROLL_PTR)字段： 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。

  如果一行记录将被更新, 则 undo log record 包含 '重建该行记录被更新之前内容' 所必须的信息。

- insert undo log只在事务回滚时需要, 事务提交就可以删掉了。update undo log包括update 和 delete , 回滚和快照读 都需要。



**在了解基本概念后来看一下mysql的InnoDB是怎么实现MVCC的**



基于一致性视图，我们就可以判断一行数据的多版本可见性了，无论是“读已提交”还是“可重复读”级别，可见性判断规则是一样的，区别在于创建快照（一致性视图）的时间。



在当前事务中，读取其他某一行的记录，对其中的版本号的可见性判断有五种情况

- 如果版本号小于“低水位”，说明事务已经提交，那肯定 可见；
- 如果版本号大于“高水位”，说明这行数据的这个事务id版本是在快照后产生的，那肯定 不可见；
- 如果版本号在事务数组array中，说明这个事务还没提交，所以 不可见；
- 如果版本号不在事务数组array中，且低于高水位，说明这个事务已经提交，所以 可见；
- 当然，无论什么时候，自己的事务id中的任何变化，都是可见的



比如说

![img](http://pcc.huitogo.club/fb2afa63fb29638e270254bffb79e208)



对于任意一行数据的可见性判断如下：

- 小于7的，可见
- 大于16的，说明是快照后产生的，不可见
- 10-15，不在数组array中，说明已经提交了，可见
- 7，8，9在array中，说明未提交，不可见



因此对于MVCC来说

- **InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。**
- **MVCC的实现，就是根据当前事务的事务id为依据创建“一致性视图”，利用一致性视图来判断数据版本的可见性。**



总结：在mysql中，提供了两种事务隔离技术，第一个是mvcc，第二个是next-key技术。这个在使用不同的语句的时候可以动态选择。不加lock inshare mode之类的就使用mvcc。否则使用next-key。mvcc的优势是不加锁，并发性高。缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。同时需要注意几点：1.事务的快照时间点是以第一个select来确认的。所以即便事务先开始。但是select在后面的事务的update之类的语句后进行，那么它是可以获取后面的事务的对应的数据。2.mysql中数据的存放还是会通过版本记录一系列的历史数据，这样，可以根据版本查找数据。



我们通过具体的实例来说明

#### 7. 并发select 

id=1 的value初始为1。

![img](http://pcc.huitogo.club/b509e2496b090589a379e2978311d56f)



我们看下，在不同隔离级别，Time5、Time7、Time9事务A查询到的value 分布为多少。

- “读未提交”：2，2，2
- “读已提交”：1，2，2
- “可重复读”：1，1，2
- 串行化：1，1，2（注意，这里在事务A提交前，事务B都会阻塞，直到事务A提交后才能执行）



#### 8. 并发update

id=1 的value初始为1，在可重复读级别：

![img](http://pcc.huitogo.club/47a0ad56ac7cc0f423343cd23e3701a4)



我们看一下，你猜猜事务A和事务B读取的value是多少？

答案是：1 和 3



可能会产生困惑，事务A在启动后快照，所以读到了1是正常的，但是事务2在启动的时候快照了，然后在自己的事务中+1，怎么会读到3而不是2呢？

原因很简单，即使是在可重复读的级别，事务 **更新数据** 的时候，只能用**当前读\**\**(加写锁)，\**而如果当前的记录的行锁被其他事务占用的话，就需要进入\**锁等待**。



同时需要注意的是事务的启动时机。

1. begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动,一致性视图是在执行第一个快照读语句时创建的。
2. 如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令，一致性视图是在执行 start transaction with consistent snapshot 时创建的。



所以在上述中，事务C在update的时候，事务B是在等待的，等事务C释放写锁，事务B执行update语句创建一致性视图的时候事务C修改的value值是可见的。



#### 9. 总结

**现在我们来总结一下mysql的MVCC**

一般我们认为MVCC有下面几个特点：

- 每行数据都存在一个版本，每次数据更新时都更新该版本

- 修改时copy出当前版本, 然后随意修改，各个事务之间无干扰

- 保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)

  就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功



而InnoDB实现MVCC的方式是:

1. 事务以排他锁的形式修改原始数据
2. 把修改前的数据存放于undo log，通过回滚指针与主数据关联
3. 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）



二者最本质的区别是: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？

Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, undo log 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。



比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 第一类更新丢失 的情况。



也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。