#### 1. B-Tree 索引

B-Tree 索引是 InnoDB 引擎的默认索引，如果我们没有特别指定索引，那么说的就是 B-Tree 索引。在 InnoDB 引擎中使用 B+树来实现 B-Tree 索引。



在 B-Tree 索引中又有主键索引和普通索引之分

##### 1.1 主键索引

主键索引也叫聚簇索引，是按照主键构建得一棵 B+树，只要建立了主键就会自动加上索引，主键索引得特点是：叶子节点上存放着整张表得行记录数据，所以叶子节点也叫数据页。



正是因为这个特点，对于主键的排序查找和范围查找速度非常快，因为索引上就有用户需要查询的数据，所以不会要回表查询



##### 1.2 普通索引

普通索引也叫二级索引，跟主键索引的主要区别在于叶子结点没有存放行记录的全部数据，只包含了需要的键值，还有一个标签，用来告诉存储引擎在哪里可以找到这行数据。



除了主键之外的索引都是普通索引。

普通索引因为行记录里没有数据的全部信息，在使用普通索引查询时，需要现在普通索引树上搜索一遍，再回到主键索引树上查询到需要的信息，这个过程也叫回表。



创建方式如下：

```
1. CREATE TABLE t( 

2. aid int unsigned not null auto_increment, 

3. userid int unsigned not null default 0, 

4. username varchar(20) not null default ‘’, 

5. detail varchar(255) not null default ‘’, 

6. primary key(aid), 

7. unique key(uid) USING BTREE, 

8. key (username(12)) USING BTREE — 此处 uname 列只创建了最左12个字符长度的部分索引 

9. )engine=InnoDB; 
```



#### 2. 哈希索引

哈希索引在 InnoDB 引擎中叫作自适应哈希索引，它是由数据库自身根据你的使用情况创建的，并不能人为的干预，所以叫作自适应哈希索引，采用的是哈希表数据结构，所以对于字典类型查询就非常的快，但是对于范围查询就无能为力啦。



哈希索引的示意图是这样的

![img](http://pcc.huitogo.club/e2c5f4badb45e403ab4ddbba117fe07c)



简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。



从上面的图来看，B+树索引和哈希索引的明显区别是：

1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
2. 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
3. 哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
4. 哈希索引也不支持多列联合索引的最左匹配规则；
5. B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。



在MySQL中，只有HEAP/MEMORY引擎表才能显式支持哈希索引（NDB也支持，但这个不常用），InnoDB引擎的自适应哈希索引（adaptive hash index）不在此列，因为这不是创建索引时可指定的。

还需要注意到：HEAP/MEMORY引擎表在mysql实例重启后，数据会丢失。



通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：

在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引

例如这种SQL：SELECT … FROM t WHERE C1 = ?; — 仅等值查询



在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。



#### 3. 全文索引

通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询。



你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。



需要注意的是

- MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；
- MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;
- 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。



创建全文索引如下：

```
1. create table fulltext_test ( 

2.   id int(11) NOT NULL AUTO_INCREMENT, 

3.   content text NOT NULL, 

4.   tag varchar(255), 

5.   PRIMARY KEY (id), 

6.   FULLTEXT KEY content_tag_fulltext(content,tag) // 创建联合全文索引列 

7. ) ENGINE=MyISAM DEFAULT CHARSET=utf8; 
```



和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如

```
1. select * from fulltext_test  

2.   where match(content,tag) against('xxx xxx'); 
```



关于全文索引的匹配需要注意两点

##### 3.1 搜索长度

MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。

这两个的默认值可以使用以下命令查看

```
# 查看变量

1. show variables like '%ft%'; 
```



全文索引的相关参数都无法进行动态修改，必须通过修改 MySQL 的配置文件来完成。修改最小搜索长度的值为 1，首先打开 MySQL 的配置文件 /etc/my.cnf，在 [mysqld] 的下面追加以下内容

```
1. [mysqld] 

2. innodb_ft_min_token_size = 1 

3. ft_min_word_len = 1 
```



然后重启 MySQL 服务器，并修复全文索引。注意，修改完参数以后，一定要修复下索引，不然参数不会生效。

两种修复方式，可以使用下面的命令修复

```
# 修复索引

1. repair table test quick;
```

或者直接删掉重新建立索引



##### 3.2 搜索类型

全文搜索有两种搜索类型



**1）自然语言的全文索引**

默认情况下，或者使用 in natural language mode 修饰符时，match() 函数对文本集合执行自然语言搜索，上面的例子都是自然语言的全文索引。

自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。上面提到的，测试表中必须有 4 条以上的记录，就是这个原因。

这个机制也比较好理解，比如说，一个数据表存储的是一篇篇的文章，文章中的常见词、语气词等等，出现的肯定比较多，搜索这些词语就没什么意义了，需要搜索的是那些文章中有特殊意义的词，这样才能把文章区分开。



**2）布尔全文索引**

在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性，当编写一个布尔搜索查询时，可以通过一些前缀修饰符来定制搜索。



MySQL 内置的修饰符，上面查询最小搜索长度时，搜索结果 ft_boolean_syntax 变量的值就是内置的修饰符，下面简单解释几个，更多修饰符的作用可以查手册

- \+ 必须包含该词
- \- 必须不包含该词
- \> 提高该词的相关性，查询的结果靠前
- < 降低该词的相关性，查询的结果靠后
- (*)星号 通配符，只能接在词后面



例如我们常见的like ‘a%’操作可如下：

```
# 全文索引匹配操作

1. select * test where match(content) against('a*' in boolean mode); 
```