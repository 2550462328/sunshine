MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

![](https://pcc.huitogo.club/mysql1.png)



上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。

![](https://pcc.huitogo.club/mysql2.png)

注意： 实际开发当中会**重点使用B+Tree**，所以我们平常所说的索引，如果没有特别指明，都是指B+Tree结构组织的索引。



#### 1. B-Tree 索引

在说B+Tree之前，我们先了解一下B-Tree，B-Tree又被称之为B树，而B+Tree是B-Tree的变种，B树是一种多叉路平衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。

以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针，指针永远比key最多多1个：

![](https://pcc.huitogo.club/mysql3.png)



B-Tree特点：

- 5阶的B树，每一个节点最多存储4个key，对应5个指针。
- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。
- 在B树中，非叶子节点和叶子节点都会存放数据。



#### 2. B+Tree

B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：

![](https://pcc.huitogo.club/mysql4.png)



我们可以看到，两部分：

- 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。
- 红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。



最终我们看到，**B+Tree 与 B-Tree相比，主要有以下三点区别**：

- 所有的数据都会出现在叶子节点。
- 叶子节点形成一个单向链表。
- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。



**上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的B+Tree。**

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。

![](https://pcc.huitogo.club/mysql5.png)



mysql当中一页代表了B+TREE数据结构当中的一个叶子节点，并且一页固定大小为16kb。

**总结：mysql的B+Tree数据结构，就是在原来的B+Tree结构基础上，将叶子节点的单向链表改为了双向链表。**



B+Tree 索引是 InnoDB 引擎的默认索引，如果我们没有特别指定索引，那么说的就是 B+Tree 索引。



在 B+Tree 索引中又有主键索引和普通索引之分

1）主键索引

主键索引也叫聚簇索引，是按照主键构建得一棵 B+树，只要建立了主键就会自动加上索引，主键索引得特点是：叶子节点上存放着整张表得行记录数据，所以叶子节点也叫数据页。



正是因为这个特点，对于主键的排序查找和范围查找速度非常快，因为索引上就有用户需要查询的数据，所以不会要回表查询



2）普通索引

普通索引也叫二级索引，跟主键索引的主要区别在于叶子结点没有存放行记录的全部数据，只包含了需要的键值，还有一个标签，用来告诉存储引擎在哪里可以找到这行数据。



除了主键之外的索引都是普通索引。



普通索引因为行记录里没有数据的全部信息，在使用普通索引查询时，需要现在普通索引树上搜索一遍，再回到主键索引树上查询到需要的信息，这个过程也叫回表。



创建方式如下：

```
1. CREATE TABLE t( 

2. aid int unsigned not null auto_increment, 

3. userid int unsigned not null default 0, 

4. username varchar(20) not null default ‘’, 

5. detail varchar(255) not null default ‘’, 

6. primary key(aid), 

7. unique key(uid) USING BTREE, 

8. key (username(12)) USING BTREE — 此处 uname 列只创建了最左12个字符长度的部分索引 

9. )engine=InnoDB; 
```



**Q1：InnoDB主键索引的B+tree高度为多高呢?**

![](https://pcc.huitogo.club/mysql6.png)



关于页相关知识：

- 一页最大为16KB，假设一行数据大小为1k，则一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键假设为bigint类型，那么就是占用字节数为8。指针的数量是键值数量+1。



**高度为2：**

- 第一步：非叶子节点是不存储数据的，那么我们可以通过已知的现有条件来算出叶子节点可以存储多少key值。 n * 8 + (n + 1) * 6 = 16*1024 ,算出n约为 1170（这里的n代表的就是key值，8代表的是假设id为8字节，n+1代表的是指针，6代表的是指针占用6字节，16*1024代表的是一页最大为16kb*1024字节数）
- 第二步：有了key值数量后，通过key+1得出指针数量，指针数量就代表着最多有多少页，因为本身高度为2，然后乘于页大小，得出最大的空间为18736：1171* 16 = 18736
- 也就是说，如果树的高度为2，假设一条数据为1kb，则可以存储 18000 多条记录。



**高度为3：**

- 1171 * 1171 * 16 = 21939856

- 有多少指针就代表有多少页，因为我们要求的是求出最大数据量，所以一个指针肯定对应一个页

- 也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。

  

#### 2. 哈希索引

哈希索引在 InnoDB 引擎中叫作自适应哈希索引，它是由数据库自身根据你的使用情况创建的，并不能人为的干预，所以叫作自适应哈希索引，采用的是哈希表数据结构，所以对于字典类型查询就非常的快，但是对于范围查询就无能为力啦。



哈希索引的示意图是这样的

![img](http://pcc.huitogo.club/e2c5f4badb45e403ab4ddbba117fe07c)



简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。



哈希索引特点

- Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，…）
- 无法利用索引完成排序操作
- 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引



在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。



从上面的图来看，B+树索引和哈希索引的明显区别是：

1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
2. 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
3. 哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
4. 哈希索引也不支持多列联合索引的最左匹配规则；
5. B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。



在MySQL中，只有HEAP/MEMORY引擎表才能显式支持哈希索引（NDB也支持，但这个不常用），InnoDB引擎的自适应哈希索引（adaptive hash index）不在此列，因为这不是创建索引时可指定的。

还需要注意到：HEAP/MEMORY引擎表在mysql实例重启后，数据会丢失。



通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：

在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引

例如这种SQL：SELECT … FROM t WHERE C1 = ?; — 仅等值查询



在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。



#### 3. 全文索引

通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询。



你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。



需要注意的是

- MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；
- MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;
- 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。



创建全文索引如下：

```
1. create table fulltext_test ( 

2.   id int(11) NOT NULL AUTO_INCREMENT, 

3.   content text NOT NULL, 

4.   tag varchar(255), 

5.   PRIMARY KEY (id), 

6.   FULLTEXT KEY content_tag_fulltext(content,tag) // 创建联合全文索引列 

7. ) ENGINE=MyISAM DEFAULT CHARSET=utf8; 
```



和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如

```
1. select * from fulltext_test  

2.   where match(content,tag) against('xxx xxx'); 
```



关于全文索引的匹配需要注意两点

##### 3.1 搜索长度

MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。

这两个的默认值可以使用以下命令查看

```
# 查看变量

1. show variables like '%ft%'; 
```



全文索引的相关参数都无法进行动态修改，必须通过修改 MySQL 的配置文件来完成。修改最小搜索长度的值为 1，首先打开 MySQL 的配置文件 /etc/my.cnf，在 [mysqld] 的下面追加以下内容

```
1. [mysqld] 

2. innodb_ft_min_token_size = 1 

3. ft_min_word_len = 1 
```



然后重启 MySQL 服务器，并修复全文索引。注意，修改完参数以后，一定要修复下索引，不然参数不会生效。

两种修复方式，可以使用下面的命令修复

```
# 修复索引

1. repair table test quick;
```

或者直接删掉重新建立索引



##### 3.2 搜索类型

全文搜索有两种搜索类型



**1）自然语言的全文索引**

默认情况下，或者使用 in natural language mode 修饰符时，match() 函数对文本集合执行自然语言搜索，上面的例子都是自然语言的全文索引。

自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。上面提到的，测试表中必须有 4 条以上的记录，就是这个原因。

这个机制也比较好理解，比如说，一个数据表存储的是一篇篇的文章，文章中的常见词、语气词等等，出现的肯定比较多，搜索这些词语就没什么意义了，需要搜索的是那些文章中有特殊意义的词，这样才能把文章区分开。



**2）布尔全文索引**

在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性，当编写一个布尔搜索查询时，可以通过一些前缀修饰符来定制搜索。



MySQL 内置的修饰符，上面查询最小搜索长度时，搜索结果 ft_boolean_syntax 变量的值就是内置的修饰符，下面简单解释几个，更多修饰符的作用可以查手册

- \+ 必须包含该词
- \- 必须不包含该词
- \> 提高该词的相关性，查询的结果靠前
- < 降低该词的相关性，查询的结果靠后
- (*)星号 通配符，只能接在词后面



例如我们常见的like ‘a%’操作可如下：

```
# 全文索引匹配操作

1. select * test where match(content) against('a*' in boolean mode); 
```