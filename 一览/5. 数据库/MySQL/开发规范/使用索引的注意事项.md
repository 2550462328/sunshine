##### 1. 索引并不是越多越好（建议单张表索引不超过 5个）

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。



因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。



##### 2. 值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段

字符字段最好不要做主键



索引列推荐

- 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列
- 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段
- 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好
- 多表 join 的关联列



##### 3. 字符字段只建前缀索引，blob和text类型字段可以建立全文索引



##### 4. 避免建立冗余索引和重复索引

增加了查询优化器生成执行计划的时间

- 重复索引示例：primary key(id)、index(id)、unique index(id)
- 冗余索引示例：index(a,b,c)、index(a,b)、index(a)



##### 5. 不用外键和级联操作，由程序保证约束



##### 6. 尽量不用UNIQUE，由程序保证约束



##### 7. 对于频繁的查询优先考虑使用覆盖索引

覆盖索引就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引



覆盖索引的好处：

- **避免 Innodb 表进行索引的二次查询**: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。

- **可以把随机 IO 变成顺序 IO 加快查询效率**: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 I



##### 8. 使用组合索引时注意最左优先原则

最左优先就是说组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到。只要组合索引最左边第一个字段出现在Where中，那么不管后面的字段出现与否或者出现顺序如何，MySQL引擎都会自动调用索引来优化查询效率。



根据最左匹配原则可以知道B-Tree建立索引的过程，比如假设有一个3列索引(col1,col2,col3),那么MySQL只会建立三个索引(col1),(col1,col2),(col1,col2,col3)。



如果一个语句是select d, e from Table where a = ? and b = ? order by c

那么组合索引顺序是a,b,c,d,e



##### 9. 使用组合索引的索引列顺序

- 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）
- 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）
- 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）



##### 10. 每个 Innodb 表必须有个主键

Innodb 是按照主键索引的顺序来组织表的

- 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）
- 不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）
- 主键建议使用自增 ID 值