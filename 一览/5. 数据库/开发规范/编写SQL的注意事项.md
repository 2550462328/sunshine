##### 1. 不做列运算

SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边



##### 2. sql语句尽可能简单

一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库



##### 3. 不用SELECT *



##### 4. 使用union联合查询手动创建临时表

在明显不会有重复值时使用 UNION ALL 而不是 UNION

- UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作
- UNION ALL 不会再对结果集进行去重操作



##### 5. OR改写成IN

OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内

in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。



##### 6. 不用函数和触发器，在应用程序实现



##### 7. 避免%xxx式查询



##### 8. 使用关联查询（ left join on）查询代替子查询

需要 join的字段，数据类型必须绝对一致，多表关联查询时，保证**被关联的字段需要有索引**。



**join不宜过多的原因**：

- 对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。
- 在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。



如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就**容易造成服务器内存溢出**的情况，就会影响到服务器数据库性能的稳定性。

同时对于关联操作来说，**会产生临时表操作，影响查询效率**，MySQL 最多允许关联 61 个表，建议不超过 5 个。



**子查询性能差的原因**：

子查询的结果集**无法使用索引**，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。



由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。



##### 9. 避免数据类型的隐式转换

隐式转换会导致索引失效

使用同类型进行比较，比如用'123'和'123'比，123和123比



##### 10. 使用BETWEEN不用IN

```
SELECT id FROM t WHERE num BETWEEN 1 AND 5
```



##### 11. 避免深度分页

列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大，使用limit分页时候，可以使用子查询优化，比如下面语句

```
// 直接limit查询

1. SELECT * FROM dispark_plat_user LIMIT 10000,100 
```



可以下面代替

```
1. SELECT a.* FROM dispark_plat_user a, (SELECT sysId FROM dispark_plat_user LIMIT 10000,100) b 

3. WHERE a.`sysId` = b.sysId 
```



##### 12. 建议**使用预编译语句**进行数据库操作

预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。

只传参数，比传递 SQL 语句更高效。

相同语句可以一次解析，多次使用，提高处理效率。

例如JDBC使用PrepareStatement



##### 13. 尽量使用批量操作

数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。

**超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作**

**大批量操作可能会造成严重的主从延迟**

主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况



**binlog 日志为 row 格式时会产生大量的日志**

大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因



**避免产生大事务操作**

大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。



特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批