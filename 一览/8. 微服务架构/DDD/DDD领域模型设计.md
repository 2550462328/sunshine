#### 1.  模型驱动设计

分层架构：DDD中将系统分为UI层，应用层，领域层以及基础设施层，其中

- User Interface

负责向用户展现信息，并且会解析用户行为，即常说的展现层。

- Application Layer

应用层没有任何的业务逻辑代码，它很简单，它主要为程序提供任务处理。

- Domain Layer

这一层包含有关领域的信息，是业务的核心，领域模型的状态都直接或间接（持久化至数据库）存储在这一层。

- Infrastructure Layer

为其他层提供底层依赖操作。

![img](http://pcc.huitogo.club/7f328670d3f3f1cc7d4b958aef1ed41e)



#### 2. 建模工具

DDD原著中提出了很多实用的建模工具：聚合、实体、值对象、工厂、仓储、领域服务、领域事件。我们可以使用这些工具，来设计每一个子域的领域模型。最终通过领域模型图将设计沉淀下来。



其中工具的概念如下：

- **实体(Entity)**

实体与面向对象中的概念类似，在这里再次提出是因为它是领域模型的基本元素。在领域模型中，实体应该具有唯一的标识符。



- **值对象(Value Object)**

值对象是没有唯一标识符的实体，值对象在领域模型中是可以被共享的，他们应该是“不可变的”（只读的），当有其他地方需要用到值对象时，可以将它的副本作为参数传递。



- **服务 **

当我们在分析某一领域时，一直在尝试如何将信息转化为领域模型，但并非所有的点我们都能用Model来涵盖。对象应当有属性，状态和行为，但有时领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务。服务是无状态的，对象是有状态的。所谓状态，就是对象的基本属性：高矮胖瘦，年轻漂亮。服务本身也是对象，但它却没有属性（只有行为），因此说是无状态的。



服务存在的目的就是为领域提供简单的方法。为了提供大量便捷的方法，自然要关联许多领域模型，所以说，行为(Action)天生就应该存在于服务中。



- **模块**

对于一个复杂的应用来说，领域模型将会变的越来越大，以至于很难去描述和理解，更别提模型之间的关系了。模块的出现，就是为了组织统一的模型概念来达到减少复杂性的目的的。而另一个原因则是模块可以提高代码质量和可维护性，比如我们常说的高内聚，低耦合就是要提倡将相关的类内聚在一起实现模块化。模块应当有对外的统一接口供其他模块调用，比如有三个对象在模块a中，那么模块b不应该直接操作这三个对象，而是操作暴露的接口。模块的命名也很有讲究，最好能够深层次反映领域模型。



- **聚合**

聚合被看作是多个模型单元间的组合，它定义了模型的关系和边界。每个聚合都有一个根，根是一个实体，并且是唯一可被外访问的。正是如此，聚合可以保证多个模型单元的不变性，因为其他模型都参考聚合的根。所以要想改变其他对象，只能通过聚合的根去操作。根如果没有了，那么聚合中的其他对象也将不存在。



一个简单的例子如下：

customer是该聚合的根，其他的都是内部对象，如果外部需要用户地址，拷贝一份传递出去即可。显而易见，用户如果不存在，其他信息均无意义。



- **工厂**

在大型系统中，实体和聚合通常是很复杂的，这就导致了很难去通过构造器来创建对象。工厂就决解了这个问题，它把创建对象的细节封装起来，巧妙的实现了依赖反转。当然对聚合也适用（当建立了聚合根时，其他对象可以自动创建）。



- **仓库**

仓库封装了获取对象的逻辑，领域对象无须和底层数据库交互，它只需要从仓库中获取对象即可。仓库可以存储对象的引用，当一个对象被创建后，它可能会被存储到仓库中，那么下次就可以从仓库取。如果用户请求的数据没在仓库中，则会从数据库里取，这就减少了底层交互的次数。



#### 3. 领域建模

下面我再讲一下我认为比较重要的东西，比如到底该如何领域建模？步骤应该是怎么样的？



**领域建模的方法**

通过上面我介绍的细化子域的内容，现在再来谈该如何领域建模，我觉得就方便很多了。

我的主要方法是：

1. 划分好边界上下文，通常每个子域（sub domain）对应一个边界上下文（bounded context），同一个边界上下文中的概念是明确的，没有任何歧义；
2. 在每个边界上下文中设计领域模型，具体的领域模型设计方法有很多种，如以场景为出发点的四色原型分析法，或者我早期写的这篇文章；这个步骤最核心的就是找出聚合根，并找出每个聚合根包含的信息；
3. 画出领域模型图，圈出每个模型中的聚合边界；
4. 设计领域模型时，要考虑该领域模型是否满足业务规则，同时还要综合考虑技术实现等问题，比如并发问题；领域模型不是概念模型，概念模型不关注技术实现，领域模型关心；所以领域模型才能直接指导编码实现；
5. 思考领域模型是如何在业务场景中发挥作用的，以及是如何参与到业务流程的每个环节的；
6. 场景走查，确认领域模型是否能满足领域中的业务场景和业务流程；
7. 模型持续重构、完善、精炼；



下图是一个普通电商系统的商品中心的领域模型图，仅供参考：

![img](http://pcc.huitogo.club/09d66cc9eb2fd73f0cd1565a7d59b0d0)



#### 4. 代码结构

从代码调用层次上来看：

![img](http://pcc.huitogo.club/c5b3e7614380aca1caa6e02517724083)



在实际开发中，我们一般会采用模块来表示一个领域的界限上下文，比如:

- 抽奖上下文:com.hafiz.business.lottery.*
- 风控上下文:com.hafiz.business.riskcontroller.*
- 奖品上下文:com.hafiz.business.prize.*
- 活动资格上下文: com.hafiz.business.qualification.*
- 库存上下文:com.hafiz.business.stock.*



对于模块内的组织结构，一般情况下我们是按照领域对象、领域服务、领域资源库、防腐层等组织方式定义的。

- 领域对象-值对象:com.hafiz.business.lottery.domain.valobj.*
- 领域对象-实体: com.hafiz.business.lottery.domain.entity.*
- 领域对象-聚合根: com.hafiz.business.lottery.domain.aggregate.*
- 领域服务:com.hafiz.business.lottery.domain.service.*
- 领域资源库:com.hafiz.business.lottery.domain.repo.*
- 领域防腐层:com.hafiz.business.lottery.domain.facade.*



代码结构如下：

![img](http://pcc.huitogo.club/6deacaf781a1fda32a6e1c4da60d79d5)



其中包信息：

- **Infrastructure 层** 

基础实施层，向其他层提供通用的技术能力(比如工具类,第三方库类支持,常用基本配置,数据访问底层实现)

![img](http://pcc.huitogo.club/1ba7c626824395a319632eeb552cdf91)



- **Domain层**

主要负责表达业务概念,业务状态信息和业务规则；是整个系统的核心层,几乎全部的业务逻辑会在该层实现。

![img](http://pcc.huitogo.club/fed55d4c714f6f20a8d619f11081fd55)



- **Application层**

 相对于领域层,应用层是很薄的一层,应用层定义了软件要完成的任务,要尽量简单。

![img](http://pcc.huitogo.club/4e6432f3c55e3739e0c8591f8a5a3714)



- **Interfaces层** 

负责向用户显示信息和解释用户命令，请求应用层以获取用户所需要展现的数据(比如获取首页的商品数据)

![img](http://pcc.huitogo.club/ea8f45672219ccaa39208b4c28ef90da)



#### 5. 其他

需要特别注意的是，领域模型设计只是整个软件设计中的很小一部分。除了领域模型设计之外，要落地一个系统，我们还有非常多的其他设计要做，比如：

- 容量规划
- 架构设计
- 数据库设计
- 缓存设计
- 框架选型
- 发布方案
- 数据迁移、同步方案
- 分库分表方案
- 回滚方案
- 高并发解决方案
- 一致性选型
- 性能压测方案
- 监控报警方案

等等。



上面这些都需要我们平时的大量学习和积累。作为一个合格的开发人员或架构师，我觉得除了要会DDD领域驱动设计，还要会上面这么多的技术能力，确实是非常不容易的。所以，千万不要以为会DDD了就以为自己很牛逼，实际上你会的只是软件设计中的冰山一角而已。