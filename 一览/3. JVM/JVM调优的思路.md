#### 1. 关于性能调优

性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。

架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。



#### 2、什么时候需要JVM调优？

- Heap内存（老年代）持续上涨达到设置的最大内存值；
- Full GC 次数频繁；
- GC 停顿时间过长（超过1秒）；
- 应用出现OutOfMemory 等内存异常；
- 应用中有使用本地缓存且占用大量内存空间；
- 系统吞吐量与响应性能不高或下降。



#### 3. JVM调优的原则

JVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：

- 大多数的Java应用不需要进行JVM优化；
- 大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；
- 上线之前，应先考虑将机器的JVM参数设置到最优；
- 减少创建对象的数量（代码层面）；
- 减少使用全局变量和大对象（代码层面）；
- 优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；
- 分析GC情况优化代码比优化JVM参数更好（代码层面）；

所以说JVM是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。



#### 4. JVM调优的目标

- 低延迟：**GC低停顿和GC低频率**；
- 低内存占用；
- 高吞吐量;

通常来说任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。



#### 5. JVM调优量化目标

- Heap 内存使用率 <= 70%;
- Old generation内存使用率<= 70%;
- avgpause <= 1秒;
- Full gc 次数0 或 avg pause interval >= 24小时 ;

当然具体的调优目标还是根据实际应用来。



#### 6. JVM调优的步骤

第1步（发现问题）：性能监控

- GC频繁
- cpu load过高
- 内存溢出（OOM）
- 内存泄露
- 死锁
- 程序响应时间较长
- …



第2步（排查问题）：性能分析

- 打印GC日志，通过GCviewer来分析异常信息
- dump出堆文件，使用内存分析工具分析文件
- 使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态



第3步（解决问题）：性能调优

- 适当增加内存，根据业务背景选择垃圾回收器
- 优化代码，控制内存使用
- 增加机器，分散节点压力
- 合理设置线程池线程数量
- 使用中间件提高程序效率，比如缓存、消息队列等



#### 7. JVM可调优的参数

关于JVM的参数说明可以看上一节

```
1.  -Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。  

2.  -Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。  

3.  -Xmn：新生代大小，包括Eden区与2个Survivor区。  

4.  -XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。  

5.  -XX:MaxDirectMemorySize=1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。  

6.  -XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。  

7.  注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。  

8.  -XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。  

9.  -XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。  

10. -XX:ParallelGCThreads=8：新生代并行收集器的线程数。  

11. -XX:MaxTenuringThreshold=10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。  

12. -XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。  

13. -XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。  

14. -XX：ThreadStackSize=0：设置线程栈的大小(0 means use default stack size)，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右
```



#### 8. JVM调优具体方法

##### 8.1 内存调优

在-XX:+PrintGCDetails后，打印Full GC后的日志

![img](http://pcc.huitogo.club/fde125d60b5ce93757fcc2af0519fd78)



可以拿到以下信息

![img](http://pcc.huitogo.club/e16d1a7ecfa8ad96360abac743c3c63a)



正常来说在程序稳定运行时，我们称Full GC后的老年代内存为活跃数据（GC清不掉），相对于活跃数据来设置其他内存

![img](http://pcc.huitogo.club/3ec72435f88d0e5c71b8a6398c92961c)



##### 8.2 低延迟优化

对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。

- 应用程序可接受的平均停滞时间: 此时间与测量的Minor
- GC持续时间进行比较。可接受的Minor GC频率：Minor
- GC的频率与可容忍的值进行比较。
- 可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。
- 可接受的最大停顿发生的频率：基本就是FullGC的频率。

其中，平均停滞时间和最大停顿时间，对用户体验最为重要。



我们可以通过PrintGCDetails的方式去观察GC的情况，包括minorGC的平均时长和频率，majorGC的平均时长和频率。

除了PrintGCDetails的方式外还可以jstat -gc的方式去打印日志观察。



某一段时间观察到的数据如下：

![img](http://pcc.huitogo.club/4ed828efadebb479f85490a6fd124abe)



如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。

新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。

所以这之间就需要一个平衡点去达到性能最大化。



##### 8.3 吞吐量优化

评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。

对于垃圾收集器来说，提升吞吐量的性能调优的目标就是**尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集**（CMS），因为这两种方式都会造成应用程序吞吐降低。**尽量在MinorGC阶段回收更多的对象**，也就是适当提高年龄界限，避免对象提升过快到老年代。





#### 9. JVM调优工具

Java VisualVM ：GC观察



借助GCViewer、GCeasy日志分析工具，可以非常直观地分析出待调优点。

可从以下几方面来分析：

- **Memory**，分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；
- **Pause**，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；





#### 10. 总结

综上所述从多方面考虑下

策略 1：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。



策略 2：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小



策略3：合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低full gc 发生的频率。



策略4：设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。



策略5：注意： 如果满足下面的指标，则一般不需要进行 GC 优化：

MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。