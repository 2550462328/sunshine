**从进程的角度出发**

#### 1. top

例如在排查项目CPU占满的情况，可以先查看哪个进程占用CPU最多

top -Hp pid 可以查看进程下线程信息，查看对应线程占用资源情况，打印如下图

![img](http://pcc.huitogo.club/30ce59d9b86e94b1bc17fdd22c178822)



这里可以看到PID为12523的线程占用CPU过多

然后我们要打印出需要具体查看的PID的16进制，用于后述堆栈查询，这里打印12523的16进制

![img](http://pcc.huitogo.club/dd4a9794d15a4f2244ea1593e0c38bff)



然后查看它的堆栈信息，查看具体的原因

![img](http://pcc.huitogo.club/5223fde404d4966fb55107d5a39e8dc1)



可以看到它具体在哪一行代码，为什么一直在运行？结合具体代码查看即可



#### 2. vmstat

vmstat是一个指定周期和采集次数的虚拟内存检测工具，可以统计内存，CPU，swap的使用情况，它还有一个重要的常用功能，用来观察进程的上下文切换。



字段说明如下:

- r: 运行队列中进程数量（当数量大于CPU核数表示有阻塞的线程）
- b: 等待IO的进程数量
- swpd: 使用虚拟内存大小
- free: 空闲物理内存大小
- buff: 用作缓冲的内存大小(内存和硬盘的缓冲区)
- cache: 用作缓存的内存大小（CPU和内存之间的缓冲区）
- si: 每秒从交换区写到内存的大小，由磁盘调入内存
- so: 每秒写入交换区的内存大小，由内存调入磁盘
- bi: 每秒读取的块数
- bo: 每秒写入的块数
- in: 每秒中断数，包括时钟中断。
- cs: 每秒上下文切换数。
- us: 用户进程执行时间百分比(user time)
- sy: 内核系统进程执行时间百分比(system time)
- wa: IO等待时间百分比
- id: 空闲时间百分比
- 从线程的角度出发



#### 3. pidstat

pidstat 是 Sysstat中的一个组件，也是一款功能强大的**性能监测**工具，top 和 vmstat 两个命令都是监测进程的内存、CPU以及 I/O 使用情况，而 pidstat命令可以检测到线程级别的。



pidstat命令线程切换字段说明如下：

- UID ：被监控任务的真实用户ID。
- TGID ：线程组ID。
- TID：线程ID。
- cswch/s：主动切换上下文次数，这里是因为资源阻塞而切换线程，比如锁等待等情况。
- nvcswch/s：被动切换上下文次数，这里指CPU调度切换了线程。



#### 4. jstack

jstack是JDK工具命令，它是一种线程堆栈分析工具，最常用的功能就是使用 jstack pid 命令查看线程的堆栈信息，也经常用来排除死锁情况。



下面我们模拟出死锁的场景，并且启动这个程序，触发这个死锁条件

接下来怎么排查呢？



首先ps -ef | grep java 查看java进程

jstack pid打印出该进程的堆栈信息

![img](http://pcc.huitogo.club/434e8645f4bf2dfcccbfe781eaba5646)



在堆栈信息的下面会显示死锁信息和死锁等待条件

![img](http://pcc.huitogo.club/413357464f9437bd696f1beeac118b0d)



#### 5. jstat

它可以检测Java程序运行的实时情况，包括堆内存信息和垃圾回收信息，我们常常用来查看程序垃圾回收情况。

常用的命令是jstat -gc pid，复杂一点是jstat -gc 10340 250 20（pid，在多少毫秒内，输出多少个）



输出信息如下：

![img](http://pcc.huitogo.club/e4e4e1fe1eae77cfa602e9387866c9c8)



信息字段说明如下：

- S0C：新生代Survivor区的from区创建空间
- S1C：新生代Survivor区的to区创建空间
- S0U：新生代Survivor区的from区使用空间
- S1C：新生代Survivor区的to区使用空间
- EC：新生代Eden区的创建空间
- EU：新生代Eden区的使用空间
- OC：老年代区的创建空间
- OU：老年代区的使用空间
- PC：永久代区的创建空间
- PU：永久代区的使用空间
- YGC：次收集器收集的次数
- YGCT：次收集器收集使用了多少秒
- FGC：全收集器收集器的次数
- FGCT：全收集器收集使用了多少秒
- GCT：次收集器和全收集器耗费的总时间



我们来看下如何通过jstat查看gc情况来排查内存泄漏的问题

我们先埋坑，原理就是ThreadLocal中的值在set之后，如果不对它进行任何get/set操作的话，这个值不会被GC回收

```
1.  @GetMapping("/memleak")  

2.  public void memleak() {  

3.      System.out.println("内存泄漏...");  

4.      Thread.currentThread().setName("thread-memleak");  

5.      ThreadLocal<Byte[]> threadLocal = new ThreadLocal<>();  

6.      threadLocal.set(new Byte[4096 * 1024]);  

7.  }  
```



在启动的时候减小jvm的堆大小（尽快内存溢出），保存dump信息和内存溢出日志，启动方式如下：

```
nohup java -jar -Xms500m -Xmx500m -XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/tmp/heapdump.hprof -XX:+PrintGCTimeStamps -XX:+PrintGCDetails
-Xloggc:/tmp/heaplog.log halo-latest.jar &
```



启动完之后使用curl调用几次内存泄漏的方法

![img](http://pcc.huitogo.club/3611610f8037a1aecdccb459e91315e3)



之后系统自然而然的出现了

![img](http://pcc.huitogo.club/65ece539977a49f99c1259d3622acddf)



在curl中，可以通过jstat -gc pid查看gc情况，可以看出内存溢出的趋势



我们可以在/tmp目录下找到内存溢出是的快照信息

![img](http://pcc.huitogo.club/5d2e58c61339daf07e2abc20920bf41f)

可以借助MAT插件导入dump信息进行分析



#### 6. jmap

jmap也是JDK工具命令，他可以查看堆内存的初始化信息以及堆内存的使用情况，还可以生成dump文件来进行详细分析。

查看堆内存情况命令jmap -heap pid。

除了直接查看进程、线程信息排查问题外，还可以借助插件



#### 7. 分析插件

##### 7.1 eclipse下MAT内存工具

MAT(Memory Analyzer Tool)工具是eclipse的一个插件(MAT也可以单独使用)，它分析大内存的dump文件时，可以非常直观的看到各个对象在堆空间中所占用的内存大小、类实例数量、对象引用关系、利用OQL对象查询，以及可以很方便的找出对象GC Roots的相关信息。



##### 7.2 idea下JProfile插件

《性能诊断利器 JProfiler 快速入门和最佳实践》：https://segmentfault.com/a/1190000017795841



#### 8. 线程频繁切换问题排查

接下来我们用上面的工具来分析一下**线程频繁切换**的问题

上下文线程频繁切换会将大量CPU时间浪费在寄存器、内核栈以及虚拟内存的保存和恢复上，导致系统整体性能下降。当你发现系统的性能出现明显的下降时候，需要考虑是否发生了大量的线程上下文切换。



我们模拟了一下频繁上下文切换的场景，每个线程都去yield操纵。CPU就会进行频繁上下文切换。

在条件触发后，**怎么确定是因为频繁的上下文切换导致的性能问题呢？**



我们执行vmstat 1 10，表示每1秒打印一次，打印10次，线程切换采集结果如下：

![img](http://pcc.huitogo.club/46e985b791d968fe67487f31e8349014)



重要关注的内容有

- r=100：说明等待的进程数量是100，线程有阻塞。
- cs=800多万：说明每秒上下文切换了800多万次，这个数字相当大了。
- us=24：说明用户态占用了24%的CPU时间片去处理逻辑。
- sy=76：说明内核态占用了86%的CPU，这里明显就是做上下文切换工作了。



调用top查看进程CPU使用情况，发现CPU被当前java进程占满了

![img](http://pcc.huitogo.club/ab58bccb28f794178e6144e050663f0b)



我们使用top -Hp 13926查看内部CPU使用情况，发现内部CPU使用比较平均

![img](http://pcc.huitogo.club/7fd951a6bdac04432574775e104a4569)



**结合上面用户态CPU只使用了24%，内核态CPU占用了76%，可以基本判断是Java程序线程上下文切换导致性能问题。**



我们再通过pidstat查看线程的切换情况

![img](http://pcc.huitogo.club/db84d44f96586a9a2ef717cd9de2e773)

可以看到单个线程的切换次数（nvcswch）几乎为0



**为什么系统的上下文切换是每秒800多万，而 Java 进程中的某一个线程切换接近0呢？**



系统上下文切换分为三种情况:

1. 多任务：在多任务环境中，一个进程被切换出CPU，运行另外一个进程，这里会发生上下文切换。
2. 中断处理：发生中断时，硬件会切换上下文。在vmstat命令中是in
3. 用户和内核模式切换：当操作系统中需要在用户模式和内核模式之间进行转换时，需要进行上下文切换,比如进行系统函数调用。



Linux 为每个 CPU 维护了一个**就绪队列**，将活跃进程按照**优先级**和**等待 CPU 的时间**排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU时间最长的进程来运行。也就是vmstat命令中的r。

那么，进程在什么时候才会被调度到 CPU 上运行呢？

进程执行完终止了，它之前使用的 CPU会释放出来，这时再从就绪队列中拿一个新的进程来运行。

为了保证所有进程可以得到公平调度，CPU时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待CPU 的进程运行。

进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。

当进程通过睡眠函数 sleep 主动挂起时，也会重新调度。

当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。

发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。



结合我们之前的内容分析，阻塞的就绪队列是100左右，而我们的CPU只有4核，这部分原因造成的上下文切换就可能会相当高，再加上中断次数是4000左右和系统的函数调用等，整个系统的上下文切换到800万也不足为奇了。Java内部的线程切换才15次，是因为线程使用**Thread.yield()来让出CPU资源，但是CPU有可能继续调度该线程**，**这个时候线程之间并没有切换**，这也是**为什么内部的某个线程切换次数并不是非常大的原因**。



#### 9. 总结*

1. 在实际线上环境中，问题可能比这些复杂的多，但是本质上都是循序渐进的排查。
2. 排查思路，首先从系统使用上（包括CPU和内存使用情况），其次从GC角度分析，分析系统GC是否健康，再可以打印堆栈信息具体查看错误原因。
3. 在性能方面也要考虑是否是发生了频繁切换上下文线程的情况，导致占用大量的CPU的时间。