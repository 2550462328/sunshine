#### 1. 对象的创建过程

new一个对象会发生什么？



这里以new Order(“1”,”女鞋”)为例

![img](http://pcc.huitogo.club/d131cb11c336a7b86c6a80ff6b89484d)



##### 1.1 类加载检查

首先会去全局常量池中找这个类的符号引用，就是Order类存不存在，然后检查Order类有没有被加载、解析和初始化过，如果没有就先加载Order类。



##### 1.2 分配内存

接着要在堆里面为Order类实例分配内存了，分配内存的方法有两种，“指针碰撞”和“空闲列表”，至于选择哪个，取决于Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

![img](http://pcc.huitogo.club/0c596326c92af0de95a94dbb50b40635)



内存分配的并发问题

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

1）**CAS+失败重试**

CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS 配上失败重试的方式保证更新操作的原子性。



2）**TLAB**： 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配



##### 1.3 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

这一步就是给Order的字段设置了初始值。



##### 1.4 设置对象头

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

也就是在Order对象的头文件里面设置一些后面操作可能会用到的信息了。



##### 1.5 执行init方法

从虚拟机来讲Order对象已经创建好了，接下来从Java角度去初始化这个对象

这一步初始化Order对象，执行代码块和构造函数。



从对象的创建过程中，我们明白了为什么static代码块只执行一次，因为它是在类加载后执行的，而类只会加载一次；而普通代码块和构造方法则是new一次执行一次，因为他们属于init方法中的操作。



#### 2. 对象内存布局

![img](http://pcc.huitogo.club/1c9baa1390b8f8c747e646ee8055e56c)

其中对齐填充不是必要的，因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。



#### 3. 对象访问定位

就是Order order = new Order(); 我们都知道order在栈中创建，new Order()在堆中创建，他们是怎么关联的？

有两种方式，句柄和直接指针的方式。直接指针故名思意就是直接执行对象的内存地址，而句柄就是借助一个中间容器（可以理解成中间表）访问对象的内存地址



下图是通过句柄访问对象的大致

![img](http://pcc.huitogo.club/311495567291f87baa19ac7253297f9d)



这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。