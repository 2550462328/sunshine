**从java-version 命令行讲起**

![img](http://pcc.huitogo.club/8bd07b701443f036ef7e2ed16050be45)



最重要的是最后一行

**1）Hotspot（热探测）**

在jdk 1.3之前 jdk将class文件放到jvm（虚拟机）中后，cpu不能直接调用，所以虚拟机要将class文件编译成native code（本地代码），也就是cpu可以直接运行的。这势必会导致性能问题。

在jdk 1.5之后 sun公司采用了hotspot技术，对于编译次数频繁的class文件给它进行标记，后面的操作类似于缓存，下次调用的时候直接调用，省去了编译成native code的过程。



Hotspot架构

![img](http://pcc.huitogo.club/9c73ca4c45b3e2d790edb819f7977f26)



**2）Client**

Java的虚拟机在虚拟机启动的时候分为client和server机制，client机制更多的是针对于桌面级应用对它的内存空间进行优化，桌面级应用是同时触发的代码量少，比如一次只能点击一个按钮，触发一个事件，所以在client机制中jvm分配的空间更少，jvm默认采用的client机制。如果要更换成server机制，在java的jre/lib/i386/jvm.cfg文件文件中调换client和server的位置，谁在前面加载谁。



![img](http://pcc.huitogo.club/94d22ca16e5f660412dc5b4bc53dbe3f)



![img](http://pcc.huitogo.club/5c284defdb120f6ac102a7b4529670a2)



**jvm的基础结构**

![img](http://pcc.huitogo.club/759a83d7f99e71fd8d3a4af905999fc4)



从线程访问划分为线程共享 和 线程独享

![img](http://pcc.huitogo.club/6f27a170f12aef7b866643465db4337d)



#### 1. 方法区

类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放在一块称为方法区的内存空间。



#### 2. java堆

java堆在虚拟机启动的时候建立，它是java程序最主要的内存工作区域，几乎所有的java对象实例都存放在java堆中。堆空间是所有进程共享的，这是一块与java应用息息相关的内存空间。

堆也是垃圾回收重点管理的区域，从GC角度来讲，可以分为新生代和永生代，而新生代又有Eden区和Survivor区。



#### 3. 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。

JDK1.4中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

Java 进程可以通过堆外存技术避免在 Java Native 堆中来回复制数据带来的资源占用和性能消耗，因此堆外内存在高并发应用场景下被广泛使用（ Netty、Flink、HBase、Hadoop 都有用到堆外内存）。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。



#### 4. 垃圾回收系统

垃圾回收器可以对方法区、直接内存和java堆进行回收，其中java堆是垃圾收集器的工作重点，和C/C++不同，java中所有对象空间的释放都是隐式的，也就是说，java中没有类似free()和delete()这样的函数释放指定的内存空间，对于不再使用的垃圾对象，垃圾回收系统会在后台默默的工作，默默查找，标识并释放垃圾对象，完成包括java堆、方法区和直接内存的自动化管理。



#### 5. java栈（虚拟机栈）

这里虚拟机栈就是我们经常说的堆栈中的栈

8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。

Java虚拟机栈是由一个个栈帧组成，栈帧用来记录方法的执行过程，在方法被执行时虚拟机会为其创建一个与之对应的栈帧， 方法的执行和返回对应栈帧在虚拟机栈中的入栈和出栈。 无论方法是正常运行完成还是异常完成（抛出了在方法内未被捕获的异常），都视为方法运行结束。



#### 6. 本地方法栈

和java栈非常类似，最大的不同是虚拟机栈面向的是字节码中的方法，本地方法栈面向的是本地方法（Native），作为对虚拟机栈的重要拓展，java虚拟机允许java直接调用本地方法，如操作系统的api，所以不同操作系统有不同操作系统的jvm。

**HotSpot虚拟机直接将虚拟机和本地方法栈合二为一了。**



#### 7. PC

PC寄存器也叫程序计数器，是每一个线程的私有空间，java虚拟机会为每一个线程创建pc寄存器，在任意时刻，一个java线程总是在执行一个方法，这个正在被执行的方法称为当前方法，如果当前方法不是本地方法，pc寄存器就会指向当前正在被执行的指令，如果是本地方法，那么pc寄存器的值为underfined。

字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了

程序计数器是唯一一个不会出现OutOfMemoryError的内存区域



#### 8. 执行引擎

是java虚拟机最核心的组件，负责执行虚拟机的字节码，现代虚拟机经过优化后可以使用即时编译技术（just in time）将方法编译成机器码后再执行。

Java hotspot Client VM :在客户端环境中减少启动时间优化。

Java hotspot Server VM :在服务器环境中最大化减少程序执行速度而设计。



client模式和server模式的区别：

当虚拟机以 -client启动后的时候，使用的是代号为c1的轻量级编译器，使用-server模式启动后，使用的代号为c2的重量级编译器，c2比c1编译的相对彻底，服务起来之后性能更高。

**在jdk 1.6之后 -client模式已经不起作用了，-server模式是唯一的。**



#### 9. 运行时常量池

运行时常量池（ Runtime Constant Pool）是每一个类或接口的常量池（ Constant_Pool）的运行时表示形式。

它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表（ SymbolTable）的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。 每一个运行时常量池都分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。



