这里虚拟机栈就是我们经常说的堆栈中的栈

8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。

Java虚拟机栈是由一个个栈帧组成，栈帧用来记录方法的执行过程，在方法被执行时虚拟机会为其创建一个与之对应的栈帧， 方法的执行和返回对应栈帧在虚拟机栈中的入栈和出栈。 无论方法是正常运行完成还是异常完成（抛出了在方法内未被捕获的异常），都视为方法运行结束。



下图展示了线程运行及栈帧变化的过程

![img](http://pcc.huitogo.club/4d7df1d6d3bb494ac11281ec08ad242d)



线程1在CPUl 上运行，线程 CPU2 上运行，在CPU 资源不够时其他线程将处于等待状态（如图等待的线程 ），等待获取 CPU时间片。而在线程内部，每个方法的执行和返回都对应 一个栈帧的入栈和出栈， 每个运行中的线程当前只有一个栈帧处于活动状态。



栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。



![img](http://pcc.huitogo.club/e0b3a6cf800b283ad92763b760f6c12f)



- 栈帧：栈中数据存储的基本单位，一个栈帧对应一个方法模块。

- 局部变量表：用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。底层为一个数字数组。

- 操作数栈：主要用于保存计算过程的中间结果。在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）。

- 动态链接：指向运行时常量池的方法引用

- 方法返回地址：方法退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。




Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。

- StackOverFlowError ：请求栈过深
- OutOfMemoryError：jvm没有内存分配了

需要注意的是这两个异常是属于Throwable，不属于Exception，所以要catch Throwable