#### 1. 标记-清除算法

分成两个阶段，第一个阶段从引用根节点开始标记所有被引用的对象，就是从根对象比如说main方法，往上遍历所有需要被引用的对象，第二阶段遍历整个堆，将没有标记的删除，没有标记意味着没有任何引用关系。

缺点：**空间问题**（标记清除后会产生大量不连续的碎片）

![img](http://pcc.huitogo.club/269aaba7768c9276a01b8edde9921061)



#### 2. 复制算法

将内存划分成两个相等的区域，每次使用只使用其中一个区域，垃圾回收时，遍历当前使用区域，把正在使用的区域中对象复制到另外一个区域中，此算法每次只处理正在使用中的区域，因此复制成本较少，同时复制过去可以做响应的内存整理，不会产生碎片问题。

缺点：**需要两倍内存空间**。就是把内存中需要GC的对象复制到另个区域进行处理，然后将原区域清空。

![img](http://pcc.huitogo.club/6169695dd960397436f40cf21715f5e0)



#### 3.  标记-整理算法

结合标记清除算法和复制方法，就是在标记-清除算法的第二阶段清除未标记对象后将存活对象“压缩”到堆中的一块，按顺序排放。既不会产生碎片，也不会产生空间内存问题。

![img](http://pcc.huitogo.club/f75bd36f126745a2ca8ef747d2b9a84e)



#### 4. 分代收集算法

也就是针对不同的代使用上述的算法

比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。