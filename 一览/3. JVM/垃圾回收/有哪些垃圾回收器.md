#### 1. 新生代收集器

##### 1.1 serial收集器

这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。

![img](http://pcc.huitogo.club/85a11a23128175d02fc995e14f5b6edb)



优点：简单高效，Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率，在VM管理内存不大的情况下（收集几十M到一两百M的新生代），停顿时间完全可以控制在几百毫秒。

打开方式：-XX：+UseSerialGC

收集算法：新生代采用复制算法，老年代采用标记-整理算法



##### 1.2 ParNew 收集器

ParNew 收集器其实就是 Serial收集器的多线程版本，除了使用多条线程进行GC外，包括serial可用的所有控制参数、收集算法、STW、对象收集规则、回收策略等都与Serial完全一样，当老年代使用CMS收集器时，新生代默认使用并行收集器。

![img](http://pcc.huitogo.club/80619429aff8685fefe4b1aef4e5802f)



在单核情况下，性能可能还比不上串行收集器，在多核下，性能比较突出。

它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作。

收集算法：新生代采用复制算法，老年代采用标记-整理算法



##### 1.3 Parallel Scavenge 收集器

跟并行收集器类似，也是用的复制算法，也是并行多线程收集器，但与其他收集器尽可能缩短垃圾回收时间不同，**它更关注的是系统的吞吐量（高效率的利用CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。**

![img](http://pcc.huitogo.club/80619429aff8685fefe4b1aef4e5802f)



**所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值**。

系统吞吐量和GC时间成反比。良好的响应速度能提升用户的体验，高吞吐量适用于后台运算而不需要太多的交互任务，可以高效率完成CPU时间，尽快完成程序的运算任务。



提供以下参数设置系统吞吐量

- -XX：MaxGCPauseMillis（毫秒数）：收集器将尽力保证内存回收花费的时间不超过设定值，但如果太小会导致GC的频率增加。
- -XX：GCTimeRatio（整数0 < GCTimeRatio < 100）：是垃圾收集时间占总时间的比例
- -XX：+UseAdaptiveSizePolicy：启动GC自适应的调节策略：不需要手动指定-Xmn
- -XX：SurviviorRatio、-XX：PretenureSizeThreshold等细节参数，VM会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大吞吐量。

收集算法：新生代采用复制算法，老年代采用标记-整理算法



#### 2. 老年代收集器

##### 2.1 Serial Old 收集器

**Serial收集器的老年代版本**，它同样是一个单线程收集器。

它主要有两大用途：一种用途是在JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS收集器的后备方案。



##### 2.2 Parallel Old 收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。



##### 2.3 CMS 收集器

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

**并发和并行的区别是，用户线程是否可以一起执行，并行仅仅是GC多线程执行，并发是用户线程参与其中，多线程执行。**



**CMS并发线程数默认 = （CPU数量+3）/ 4**

当CPU数>4的时候，GC线程最多占用不超过25%的CPU资源，当CPU数<=4的时候，GC线程可能会过多的占用用户CPU资源，导致应用程序变慢，总吞吐量降低。



**CMS 收集器是基于“标记-清除”算法实现的。**

GC过程如下：

![img](http://pcc.huitogo.club/6e2cc77b428a42ae369e58b9979bfd57)



其中标记过程：

1. **初始标记**： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快；
2. **并发标记**： 同时开启 GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
3. **重新标记**： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
4. **并发清除**： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。



CMS 收集器优点：**并发收集、低停顿**

CMS 收集器缺点：**对 CPU 资源敏感**、**无法处理浮动垃圾**、**产生内存碎片**



**关于CMS产生内存碎片问题的解决：**

使用-XX：+useCMSCompactAtFullCollection用于在Full GC后再执行一个碎片整理过程，但是这样势必导致Full GC次数频繁，可以设置-XX：CMSFullGCBeforeCompaction用于设置在执行N次不进行内存整理的Ful GC后，跟着来一次带整理的（默认为0，每次进行Full GC都进行内存整理）。



对于上述新老收集器组合如下：

![img](http://pcc.huitogo.club/c3a2a3071e1d80402ca780a8aaca5a84)

**建议组合parNew （新生代）+ CMS（老年代）**



#### 3. G1收集器

**G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多个处理器及大容量内存的机器，以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。**

开启方式：--XX：+UseG1GC



作为新一代的万能收集器，它的特点如下：

1. **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
2. **分代收集**：跟其他基于分代的收集器不同，G1将整个java堆划分成多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，他们都是一部分区域（不需要连续）的集合。
3. **空间整合**：与 CMS 的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
4. **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和CMS 共同的关注点，但 G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M 毫秒的时间片段内。



G1 收集器的运作大致分为以下几个步骤：

![img](http://pcc.huitogo.club/1339ae1f431a6096f4e264d1040af3a1)

**G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region划分内存空间以及有优先级的区域回收方式，保证了 G1收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。



#### 4. ZGC收集器

![img](http://pcc.huitogo.club/c3dc47e610b5938414161563fc567108)



**主要特性**

- 着色指针
- 读屏障
- 并发处理
- 基于region
- 内存压缩(整理)



**处理过程**

- roots标记：标记root对象,会StopTheWorld
- 并发标记：利用读屏障与应用线程一起运行标记,可能会发生StopTheWorld
- 清除会清理标记为不可用的对
- roots重定位：是对存活的对象进行移动,以腾出大块内存空间,减少碎片产生.重定位最开始会StopTheWorld,取决于重定位集与对象总活动集的比例
- 并发重定位与并发标记类似



#### 5. 收集器对比

对于收集器的对比如下：

!(http://pcc.huitogo.club/4548fa3035696dc578895784ccf1535f)

![img](http://pcc.huitogo.club/5530ec98eab680497dd1e4328185c2c7)

- 到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old

- 从jdk9开始，G1收集器成为默认的垃圾收集器 目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。