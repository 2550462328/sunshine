这个问题实质上也是说怎么判断一个对象或者一个类“死了”。

#### 1、怎么判断一个对象无效？

##### 1.1 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

![img](http://pcc.huitogo.club/f529076ce450eabe9aeebdaf8cf85e3d)

优点：效率高。

缺点：它很难解决对象之间相互循环引用的问题。所谓对象之间的相互引用问题，**故java中没有采取**



如下面代码所示：除了对象objA 和 objB相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。

```
1.  public static void main(String[] args) {  

2.          ReferenceCountingGc objA = new ReferenceCountingGc();  

3.          ReferenceCountingGc objB = new ReferenceCountingGc();  

4.          objA.instance = objB;  

5.          objB.instance = objA;  

6.          objA = null;  

7.          objB = null;  

8.      }  
```



##### 1.2 可达性分析

这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots 没有任何引用链相连的话，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。

在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象



![img](http://pcc.huitogo.club/d652e3e51b02855982217f7351bef615)



在Java语言汇总能作为GC Roots起点的对象分为以下几种：

- 虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）
- 方法区中静态变量所引用的对象（静态变量）
- 方法区中常量引用的对象
- 本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C•函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）
- 已启动的且未终止的Java线程



**不可达的对象必然会被回收吗？**

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；



标记过程如下：

![img](http://pcc.huitogo.club/2dc4b21877add1ad1d97002fe37a4622)

总结出来就是在**对象不可达时会在它的finalize方法中给它最后一次机会**



使用不可达来分析不可用对象的优缺点

优点：可以解决循环依赖问题

缺点：耗费资源，进行分析的时候需要暂停用户进程，因为它要保证自己搭建的“二叉树”不能变化。



#### 2、除了对象无效外还有哪些情况可以回收？

这个要从对象引用类型上来讲了



JDK1.2 以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）

- 强引用：Java 虚拟机宁愿抛出 OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
- 软引用：在内存不够的情况下才会回收软引用类型对象。建议和ReferenceQueue联合使用，在对象被回收前能做些什么。
- 弱引用：只要发生GC，就回收弱引用对象。建议和ReferenceQueue联合使用，在对象被回收前能做些什么。
- 虚引用：跟没有一样，在任何时候都可能被垃圾回收。必须和ReferenceQueue联合使用。一般用来**跟踪对象被垃圾回收的活动**。



在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。**



#### 3. 除了对象需要回收，还有其他的吗？

##### 3.1 无用的常量

如何判断一个常量是没用的常量？

例如常量池中有字符串”aa”，如果没有String对象引用这个字符串常量，说明”aa”是一个无用的常量，在发生内存回收的时候可能会被清理出常量池。



##### 3.2 无用的类

如何判断一个类是没用的类？

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



虚拟机可以对满足上述 3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



#### 4. JVM在任何时间点都可以回收内存吗？

不，需要程序进入**安全区** 或 **安全点**

##### 4.1 安全区

JVM安全区（SafePoint）是Java虚拟机（JVM）中的一种机制，用于确保在特定的执行点上所有线程都处于安全状态。在安全区域内，JVM可以执行一些需要线程同步的操作，例如垃圾回收、线程停止等。

当JVM需要执行一个安全区操作时，它会暂停所有线程的执行，等待它们到达一个安全点，然后进行所需的操作。安全点是程序执行的特定位置，例如方法调用、循环的迭代点等。在安全点上，线程的栈帧可以被检查和修改，而不会导致数据不一致或其他问题。

在安全区域内，JVM可以执行一些需要线程同步的操作，例如垃圾回收、线程停止等。这是因为在安全区域内，JVM可以确保所有线程都暂停执行，并且不会对共享数据造成破坏。安全区域的存在可以保证线程安全和数据一致性。

JVM安全区域的概念对于垃圾回收器的实现非常重要。当进行垃圾回收时，JVM需要确保没有线程在访问被回收的对象，以避免数据不一致或潜在的并发问题。因此，在进行垃圾回收之前，JVM会进入安全区域，暂停所有线程的执行，然后执行垃圾回收操作。

总之，JVM安全区是一种保证线程安全和数据一致性的机制，在某些操作（如垃圾回收）需要对所有线程进行同步时起到关键作用。


##### 4.2 安全点

在HotSpot中，有个数据结构（映射表）称为「OopMap」。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过 程中，也会在「特定的位置」生成 OopMap，记录下栈上和寄存器里哪些位置是引用。



这些特定的位置主要在：

- 循环的末尾（非 counted 循环）

- 方法临返回前 / 调用方法的call指令后

- 可能抛异常的位置

  

这些位置就叫作「安全点(safepoint)。」 用户程序执行时并非在代码指令流的任意位置都能够在 停顿下来开始垃圾收集，而是**必须是执行到安全点**才能够暂停。