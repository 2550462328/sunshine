类的生命周期如下图：



![img](http://pcc.huitogo.club/78118e028b23915da98b1e1df022c412)



#### 1. 加载

类的加载主要是下面三个过程

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的**静态存储结构**转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口

第一个过程对于**非数组类用户是可以自定义**的，我们可以重写类加载器的loadClass()方法，常见的有从本地系统中直接加载、通过网络下载.class文件 、从zip，jar等归档文件中加载.class文件 等。



数组类就不可以了，它是**由jvm直接控制**的，数组类有以下一些特征：

- **数组类是在JVM运行时创建的**，没有对应的class 文件。
- 数组的类名是：[ 开头的，类名根据维度变化，比如：int[] 的类名是：[I ；int[][]的类名是:[[I （其中的 I 是 int类型的在虚拟机指令中数据类型）。这是两个不同的类。
- 数组类中不包含任何成员和变量，数组的长度length是通过JVM的指令 arraylength直接得到的。
- **类的加载的最终产品是位于堆区中的Class对象**，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口 

![img](http://pcc.huitogo.club/55e97c3346dc9a3771be0d06a6542666)

需要注意的是，加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。



#### 2. 连接

##### 2.1 验证

当一个类被加载之后，必须要验证一下这个类是否合法，这个阶段的目的就是保证加载的类是能够被jvm所运行。



验证步骤如下

![img](http://pcc.huitogo.club/a7db4fac204719c1f922b6eace0ba394)



##### 2.2 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

需要注意的是这里只设置类变量（static修饰的变量）的初始值，实例变量的初始值随对象的实例化而一起在堆里分配。



对于初始值如下

![img](http://pcc.huitogo.club/ae9e9272fc7816ce8ead1769d54d7c63)



特殊情况：**对于被final修饰的变量在准备阶段会直接设置值**。



##### 2.3 解析

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**。解析动作主要针对**类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符**7类符号引用进行。

举个例子：我们要找一个人，我们现有的信息是这个人的身份证号是1234567890。只有这个信息我们显然找不到这个人，但是通过公安局的身份系统，我们输入1234567890这个号之后，就会得到它的全部信息：比如山东省滨州市滨城区18号张三，通过这个信息我们就能找到这个人了。这里，123456790就好比是一个符号引用，而山东省滨州市滨城区18号张三就是直接引用。

在内存中也是一样，比如我们要在内存中找一个类里面的一个叫做show的方法，显然是找不到。但是在解析阶段，jvm就会把show这个名字转换为指向方法区的的一块内存地址，比如c17164，通过c17164就可以找到show这个方法具体分配在内存的哪一个区域了。这里show就是符号引用，而c17164就是直接引用。**在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。**



#### 3. 初始化

在类的初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋值，在程序中，类的初始化有两种途径：

1. 在变量的声明处赋值。
2. 在静态代码块处赋值。



比如下面的代码，a就是第一种初始化，b就是第二种初始化

```
1.  public class Test    

2.  {    

3.      public static int a = 0;    

4.      public static int b ;    

5.      static{    

6.          b=2;    

7.      }    

8.  }    
```



**类的静态变量的初始化是有顺序的。顺序为类文件从上到下进行初始化**。

Java程序对类的使用方式可分为主动使用和被动使用，而所有的Java虚拟机实现必须在每个类或接口被Java程序“**首次主动使用**”时才初始化它们，**如果只是调用子类中的父类方法或者属性，那么子类仍不会初始化**



**主动使用**有以下七种

- 创建类的实例 
- 访问某个类或接口的静态变量，或者对该静态变量赋值 
- 调用类的静态方法 
- 反射（如Class.forName(“com.bzu.csh.Test”)） 
- 创建一个类的子类的实例 
- Java虚拟机启动时被标明为启动类的类（Java Test） 
- 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

除了上述七种情形，其他使用Java类的方式都被看作是被动使用，不会导致类的初始化。比如调用ClassLoader类的loadClass方法加载一个类。



这里需要强调的是子类初始化之前必须初始化它的父类这条**不适用于接口**，**除非接口里有default方法**

- 在初始化一个类时，并不会先初始化它所实现的接口
- 在初始化一个接口时，并不会先初始化它的父接口



总结了下**初始化步骤**

1. 假如一个类还没有被加载或者连接，那就先加载和连接这个类
2. 假如类存在直接的父类，并且这个父类还没有被初始化，那就先初始化直接的父类
3. 假如类中存在初始化语句，那就直接按顺序执行这些初始化语句



**不会执行初始化的场景**

- 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
- 定义对象数组，不会触发该类的初始化。
- 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
- 通过类名获取 Class 对象，不会触发类的初始化。
- 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
- 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。



对于初始化的顺序有个小坑的面试题

```
1.  public class Test1 {  

2.      private static Test1 singleton = new Test1();  

3.      public static int counter1;  

4.      public static int counter2 = 0;  

5.      private Test1()  

6.      {  

7.          counter1++;  

8.          counter2++;  

9.      }  

10.     public static Test1 getInstance()  

11.     {  

12.         return singleton;  

13.     }  

14. }  

15. public class Test {  

16.     public static void main(String[] args) {  

17.         Test1 singleton = Test1.getInstance();  

18.         System.out.println("counter1 = " + singleton.counter1);  

19.         System.out.println("counter2 = " + singleton.counter2);  

20.     }  

21. }  
```



可以猜测一下这里会输出什么？

答案是**1，0**



我们从类的生命周期来分析

1. 首先主动调用Test1的getInstance静态方法，Test1进行初始化
2. 初始化之前要对Test1进行加载和连接，在连接的准备阶段，对counter1和counter2设置初值0
3. **在初始化阶段遵循从上往下的原则**，首先初始化singleton ，调用了Test1的私有构造方法，counter1和counter2被设置为1
4. 往后counter1没有赋值不用初始化，counter2赋值为0，所以初始化为0
5. 最后调用getInstance方法，返回初始化后的singleton，也就是Test1 类





#### 4. 卸载

卸载类即该类的Class对象被GC。



卸载类需要满足3个要求:

- 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
- 该类没有在其他任何地方被引用
- 该类的类加载器的实例已被GC



所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。



#### 5. 场景思考

```
1.  public class Test1 {  

2.      public static void main(String[] args) {  

3.          Student student = new Student();  

4.          student.sayName();  

5.      }  

6.  }  
```



根据类的生命周期 我们来思考下下面代码怎么执行的

1. 首先main方法是程序的主入口，所以JVM让类加载器遵循“双亲委托原则”从classpath中将Test1.class加载到内存中
2. 执行main方法，main方法入栈
3. 接下来实例化Student对象，检查Student类有没有加载，没有加载先加载到方法区，加载之后
4. 在main方法的局部变量表加入student引用，在堆里分配内存生成Student实例
5. 堆里的Student实例保持着对方法区中Student类信息的引用
6. 而栈里的Student引用有着堆里Student实例的地址，可以是直接指针或者句柄地址
7. sayName()入栈，执行sayName方法，顺着Student引用找到Student实例，再找到方法区中Student类信息里的方法表，找到之后交给CPU执行
8. sayName()执行完毕 -> 出栈
9. main方法执行完毕 -> 出栈
10. student变量销毁
11. 程序结束