之前我们讲过的字符串KMP算法对目标串和字符串的匹配工作是从index = 0 开始的，而BM算法的匹配工作是从尾部开始的，也就是index = n -1；因为BM认为，从头判断多没劲，遇到失配的情况也就移动那么几位，从尾部匹配的话有失配的情况我可以移动一大截。



所以在某些情况下，BM算法效率 > KMP算法效率 > 传统暴力求解



![img](http://pcc.huitogo.club/2a7e7230e0d643b8287d987fde760047)



那失配的时候目标串上的游标应该移动多少位呢？



这就要说到**坏字符**和**好后缀**了

在失配的时候当前匹配的字符就是坏字符，在此之前已经成功匹配的字符串就是好后缀



**1. 坏字符**

对于坏字符有两种情况

**1）坏字符在格式串中**

这时将格式串的第一个（从右边算起）出现的坏字符和目标串的坏字符对齐，当然这种方式会造成格式串倒退移动。

![img](http://pcc.huitogo.club/46c8c81ae0fbac6ba8af2bc8f868da64)



**2）坏字符不在格式串中**

这时直接将模式串自动到坏字符的下一个字符，继续比较

![img](http://pcc.huitogo.club/c612fbf061b3170b5f35930f8de882c2)



对于坏字符，我们需要计算出每个坏字符在模式串中应该移动的位置，我们不妨定义一个65536大小的数组（可以容纳所有的字符），记录字符在模式串中距离尾部的距离。



示例代码如下：

```
1. /** 

2. * 坏字符忽略数组 

3. * 

4. * @param P 模式字符串字节数组 

5. * @return int[] 忽略数组 

6. */ 

7. public static int[] bmBc(char[] P) { 

8.   // 这里65536代表装载所有的char字符 

9.   int[] bmBc = new int[65536]; 

10.  

11.   Arrays.fill(bmBc, -1); 

12.  

13.   int m = P.length; 

14.  

15.   // 填充字符序号，后面出现的重复字符会替代前面出现字符的值 

16.   for (int i = 0; i < m; i++) { 

17.     bmBc[P[i]] = m - 1 - i; 

18.   } 

19.  

20.   return bmBc; 

21. } 
```



这种算法的核心就是对于模式串中出现重复的字符时，记录的值是最右边出现的字符的距离，因为它会替代之前的。



**2. 好后缀**

对于好后缀有三种情况



1）模式串中有子串匹配好后缀

就是模式串中还有相同的片段跟已经匹配成功的好后缀一致，这种情况直接将子串和好后缀对齐，如果出现多个子串和好后缀匹配的情况，选择**最左边的子串**对齐

![img](http://pcc.huitogo.club/2f234a11062cfb11bbb4e9b77916afab)



2）模式串中没有子串匹配好后缀

这时需要寻找模式串中的一个最长前缀，并让该前缀的最长前缀等于好后缀的后缀，然后对齐

![img](http://pcc.huitogo.club/a10216da2be04c1552d9cbd02ec23454)



3）模式串没有子串匹配好后缀，并且在模式串中找不到最长前缀等于好后缀的后缀

这时就直接移动模式串到好后缀的下一个字符



对于求解在好后缀情况下的模式串移动距离，先计算下在不同边界i下和模式串后缀匹配的最大长度，比如模式串的最大下标是m，对于i需要满足P[i-s,i] == P[m-s,m]，求得s的最大值

![img](http://pcc.huitogo.club/91f49e3a778efe528fe1e443501e3db6)



示例代码

```
1. /** 

2. * 返回模式串的后缀长度数组 

3. * 

4. * @param P 

5. * @return int[] 

6. */ 

7. public static int[] suffix(char[] P) { 

8.  

9.   int m = P.length; 

10.  

11.   int[] suffix = new int[m]; 

12.  

13.   suffix[m - 1] = m; 

14.  

15.   for (int i = m - 2; i >= 0; --i) { 

16.     int p = i; 

17.  

18.     while (p >= 0 && P[p] == P[m - 1 - i + p]) { 

19.       p--; 

20.     } 

21.  

22.     suffix[i] = i - p; 

23.   } 

24.   return suffix; 

25. } 
```



接下来计算好后缀在不同的长度i下的移动位数，bmgs[i]表示遇到好后缀的时候模式串应该移动的距离，i表示好后缀前面一个字符的位置。



其中也对上述好后缀的三种情况进行考虑，根据三种情况下会移动距离的从大到小进行排列，为什么这么排列？因为我们肯定希望移动距离不要出现差错，也就是越小越好。



第三种情况：直接赋值m



第二种情况

为什么i从大到小？

原因在于，如果i,j（i > j）同时满足第二种情况，那么m-1-i < m-1-j，而我们希望每个位置只能被修改一次，故而应该赋值m-1-i，毕竟它小。



第一种情况

为什么i从小到大？

原因在于如果suff[i] == suff[j]，i<j，那么m-1-i>m-1-j，我们应该取后者作为bmGs[m-1-suff[i]]的值

```
1. /** 

2.  * 好后缀忽略映射 

3.  * 

4.  * @param P 

5.  * @return int[] 

6.  */ 

7. public static int[] bmGs(char[] P) { 

8.   // 初始化忽略数组 

9.   int m = P.length; 

10.   int[] bmgs = new int[m]; 

11.  

12.   // 后缀数组 

13.   int[] suffix = suffix(P); 

14.  

15.   Arrays.fill(bmgs, m); 

16.  

17.   // 模式串中没有子串匹配上好后缀，但找到了一个最大后缀 

18.   for (int i = m - 1, j = 0; i >= 0; --i) { 

19.     if (suffix[i] == i + 1) { 

20.       for (; j < m - 1 - i; ++j) { 

21.     // 保证每个位置最多赋值一次

22.         if (bmgs[j] == m) { 

23.           bmgs[j] = m - 1 - i; 

24.         } 

25.       } 

26.     } 

27.   } 

28.  

29.   // 模式串中有字串匹配上好后缀 

30.   for (int i = 0; i <= m - 2; i++) { 

31.     bmgs[m - 1 - suffix[i]] = m - 1 - i; 

32.   } 

33.  

34.   return bmgs; 

35. } 
```



在有了坏字符和好后缀情况下模式串移动的距离后，就好办了，取两者较大值即可



示例代码

```
1. /** 

2. * bm算法查询，核心是倒序比较，在失配的时候比较坏字符和好后缀的移动位置，取其中较大值 

3. * 

4. * @param pattern 

5. * @param target 

6. * @return int 

7. */ 

8. public static int bmSearch(String pattern, String target) { 

9.   char[] P = pattern.toCharArray(); 

10.   char[] T = target.toCharArray(); 

11.  

12.   // 获取忽略数组 

13.   int[] bmBc = bmBc(P); 

14.   int[] bmGS = bmGs(P); 

15.  

16.   int j = 0; 

17.   int m = P.length; 

18.   int n = T.length; 

19.  

20.   while (j <= n - m) { 

21.     // 倒序匹配字符 

22.     int i = m - 1; 

23.  

24.     while (i >= 0 && P[i] == T[i + j]) { 

25.       i--; 

26.     } 

27.  

28.     // 全部匹配 i = -1 

29.     if (i < 0) { 

30.       return j; 

31.     } 

32.  

33.     // 取好后缀和坏字符中移动位置最大的 

34.     j += Math.max(bmGS[i], bmBc[T[i + j] - m + 1 + i]); 

35.   } 

36.   return -1; 

37. } 
```