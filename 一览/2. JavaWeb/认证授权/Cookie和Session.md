#### 1. 什么是认证（Authentication）

通俗地讲就是验证当前用户的身份，证明“你是你自己”，比如用户名密码登录



#### 2. 什么是授权（Authorization）

**用户授予第三方应用访问该用户某些资源的权限**



比如你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）



实现授权的方式有：cookie、session、token、OAuth



#### 3. 什么是凭证（Credentials）

**实现认证和授权的前提是需要一种媒介（证书）来标记访问者的身份**



在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是**认证的凭证**。



#### 4. 什么是 Cookie

**HTTP是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）**：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就**必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器**。而这个状态需要通过 cookie 或者 session 去实现。



**cookie存储在客户端**： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。



**cookie是不可跨域的**： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。



cookie 重要的属性

![img](http://pcc.huitogo.club/be861c8320af4a7ea489738fdb293dc8)



#### 5. 什么是Session?

**session是另一种记录服务器和客户端会话状态的机制**



**session是基于 cookie实现的，session存储在服务器端，sessionId会被存储到客户端的cookie中**



![img](http://pcc.huitogo.club/53c16fe321b11990817f965274c73775)



**session认证流程：**

1. 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
2. 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
3. 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
4. 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。



根据以上流程可知，**SessionID是连接 Cookie和 Session的一道桥梁**，大部分系统也是根据此原理来验证用户登录状态。



#### 6. Cookie和 Session的区别

**安全性**： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。

**存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。

**有效期不同**： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。

**存储大小不同**： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。



#### 7. 没有Cookie的话Session还能用吗？

一般是通过 Cookie 来保存 SessionID ，假如你使用了 Cookie 保存 SessionID的方案的话， 如果客户端禁用了Cookie，那么Session就无法正常工作。



但是，并不是没有 Cookie 之后就不能用 Session 了，比如你可以将SessionID放在请求的 url 里面https://javaguide.cn/?session_id=xxx 。

这种方案的话可行，但是安全性和用户体验感降低。当然，为了你也可以对 SessionID 进行一次加密之后再传入后端。



#### 8. 使用Cookie需要考虑的问题

1. 因为存储在客户端，容易被客户端篡改，使用前**需要验证合法性**
2. **不要存储敏感数据**，比如用户密码，账户余额
3. 使用 httpOnly 在一定程度上提高安全性
4. 尽量**减少cookie的体积**，能存储的数据量不能超过 4kb
5. 设置正确的 domain 和 path，减少数据传输
6. **cookie无法跨域**
7. 一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie

移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token



#### 9. 使用Session需要考虑的问题

1. 将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的**内存**，需要在服务端定期的去清理过期的 session
2. 当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 **session共享的问题**。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。
3. 当多个应用要共享 session 时，除了以上问题，还会遇到**跨域问题**，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。
4. sessionId 是存储在 cookie 中的，假如浏览器**禁止cookie** 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现

**移动端对cookie的支持不是很好**，而 session 需要基于 cookie 实现，所以移动端常用的是 token



#### 10. session什么时候会被清除？

**只要关闭浏览器，session真的就消失了？**



不对。对 session 来说，**除非程序通知服务器删除一个session，否则服务器会一直保留**，程序一般都是在用户做 log off 的时候发个指令去删除 session。



然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。



恰恰是**由于关闭浏览器不会导致session被删除，迫使服务器为 session设置了一个失效时间，当距离客户端上一次使用 session的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session删除以节省存储空间**。