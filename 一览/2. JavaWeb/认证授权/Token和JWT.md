### 1. 什么是Token

#### 1.1 Accesss Token

**访问资源接口（API）时所需要的资源凭证**



**简单 token的组成**： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）



**特点**：

- **服务端无状态化、可扩展性好**
- **支持移动端设备**
- 安全，可以防止CSRF攻击
- 支持跨程序调用



**token的身份验证流程：**



![img](http://pcc.huitogo.club/7bc1029f4695c5c8ae9b5335519f772e)

1. 客户端使用用户名跟密码请求登录

2. 服务端收到请求，去验证用户名与密码

3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里

5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token

6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据




**每一次请求都需要携带 token，需要把 token放到 HTTP的 Header里**



**基于 token的用户认证是一种服务端无状态的认证方式，服务端不用存放 token数据。用解析 token的计算时间换取 session的存储空间，从而减轻服务器的压力，减少频繁的查询数据库**



**token完全由应用管理，所以它可以避开同源策略**



#### 1.2 Refresh Token

refresh token 是专用于**续签** access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。



![img](http://pcc.huitogo.club/fd9c02fb3259c358acadf31019b07468)



Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。



Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。



### 2. Token和 Session的区别

1）Session 是一种**记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息**。而 Token 是令牌，**访问资源接口（API）时所需要的资源凭证。Token使服务端无状态化，不会存储会话信息。**



2）Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加Session来在服务器端保存一些状态。**



3）所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。



所以简单来说：**如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用 Token。如果永远只是自己的网站，自己的 App，用什么就无所谓了。**



### 3. 什么是 JWT

**JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。**



**是一种认证授权机制**

**JWT是为了在网络应用环境间传递声明而执行的一种基于 JSON的开放标准（RFC 7519）。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。**



可以借助https://www.jsonwebtoken.io/ 生成JWT



**JWT的原理：**

![img](http://pcc.huitogo.club/28bf02775c728a77a9872f7237feda97)



**JWT认证流程：**

1. 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT

2. 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）

3. 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样

   Authorization: Bearer <token>

4. 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为

5. 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要

6. 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）

7. 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制




### 4. Token和 JWT的区别

**相同：**

都是访问资源的令牌

都可以记录用户的信息

都是使服务端无状态化

都是只有验证成功后，客户端才能访问服务端上受保护的资源



**不同：**

Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。

JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。



### 5. 使用Token需要考虑的问题

1. 如果你认为**用数据库来存储token** 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。

2. token 完全由应用管理，所以它可以避开同源策略

3. token 可以避免 CSRF 攻击(因为不需要 cookie 了)

4. 移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token

5. 注销登录等场景下 token 还有效




与之类似的具体相关场景有：

退出登录;

修改密码;

服务端修改了某个用户具有的权限或者角色；

用户的帐户被删除/暂停。

用户由管理员注销；



总结了下面几种方案：

**1）将 token存入内存数据库**：将 token 存入 DB 中，redis 内存数据库在这里是是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。



**2）黑名单机制**：和上面的方式类似，使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到 黑名单 即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。



**3）修改密钥** (Secret) : 我们为每个用户都创建一个专属密钥，如果我们想让某个 token 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大，比如：a. 如果服务是分布式的，则每次发出新的 token 时都必须在多台机器同步密钥。为此，你需要将必须将机密存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。b. 如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。



**保持令牌的有效期限短并经常轮换** ：很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。



我觉得比较好的方式：**使用用户的密码的哈希值对token进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。**



### 6. 使用 JWT时需要考虑的问题

1. 因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）

2. JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。

3. JWT 不加密的情况下，不能将秘密数据写入 JWT。

4. JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。

5. JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。

6. JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。

7. JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。

8. 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。




### 7. Token和JWT的安全问题

基于Session和cookie保存用户状态并借此验证用户会带来CSRF问题



**什么是CSRF问题呢？**

CSRF（Cross Site Request Forgery）一般被翻译为 **跨站请求伪造**



比如小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。

```
1. <a src=http://www.mybank.com/Transfer?bankId=11&money=10000>科学理财，年盈利率过万</> 
```



导致这个问题很大的原因就是： Session 认证中 Cookie 中的 session_id 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。



而Token和JWT是不会存在这个问题的？

因为就算小壮在当前页面误点了什么链接，这个Token和JWT也不会自动传递过去



但是Token和JWT会有XSS问题



**什么是XSS问题呢？**

就是黑客利用HTML解析这一个特性，伪造页面内容，比如<iframe></iframe>，黑客在伪造页面里面设法获取你的Token或者JWT信息，然后再利用你的Token和JWT信息去做非发交易。



**怎么解决呢？**

你可以选择将 token 存储在标记为httpOnly 的cookie 中。但是，这样又导致了你必须自己提供CSRF保护。

还有一个SQL脚本注入安全攻击，这里都不涉及。