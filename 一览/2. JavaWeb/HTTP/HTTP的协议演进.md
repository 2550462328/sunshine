**HTTP1.0、HTTP1.1、HTTP2.0的关系和区别**

![img](http://pcc.huitogo.club/d350d4b34c20b959601ce05c3cff46b7)



#### 1. HTTP1.0

浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。



#### 2. HTTP1.1

##### 2.1 长连接

在HTTP/1.0中，默认使用的是短连接HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。HTTP/1.1的持续连接有非流水线方式和流水线方式。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。

但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。



##### 2.2 错误状态响应码

在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。



##### 2.3 缓存处理

在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。



##### 2.4 带宽优化及网络连接的使用

HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。



#### 3. HTTP2.0

HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到 数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了 序列，服务器就可以并行的传输数据，这就是流所做的事情。

流（stream） 已建立连接上的双向字节流 消息 与逻辑消息对应的完整的一系列数据帧 帧 HTTP2.0 通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（stream id）。



##### 3.1 多路复用

从下图可以看出在HTTP1.0和HTTP1.1协议下的请求都是串行的，只有在一个请求得到响应之后才会发起下一个请求；而HTTP2.0允许同时发起多个请求，但是这并不意味它打开了更多的TCP连接来处理请求，相反还是只有一个TCP连接，HTTP2.0采用的正是**多路复用**的交互方式。

![img](http://pcc.huitogo.club/e6c33d395dab7e69173afa3878a1c66e)



1. 所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流。

2. 每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据 每个帧头部的流标识符（stream id）重新组装。

   举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录 着stream id用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据 stream id将帧再归属到各自不同的请求当中去。

3. 另外，多路复用（连接共享）可能会导致关键请求被阻塞。HTTP2.0里每个数据流都可以设置优 先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子 数据流。

4. 可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个 强大的功能则是基于“二进制分帧”的特性。

![img](http://pcc.huitogo.club/6851717215a4759a54318863921684d4)



**为什么HTTP2.0可以多路复用呢？一个tcp连接通道同时处理多个请求？**

原理在于HTTP2.0将把 HTTP 协议通信的基本单位缩小为一个一个的帧。

![img](http://pcc.huitogo.club/9213a8163c2f002cf956347d12c86bdb)



在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码，在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码



##### 3.2 首部压缩

在HTTP1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负 荷。

HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表， 既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩 header，减少发送包的数量从而降低延迟。

HTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生，SPDY 使用的是通用的DEFLATE算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK算法。

![img](http://pcc.huitogo.club/0a7cd5403e94b839ef49bc2f8a2126e5)



##### 3.3 服务端推送

服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。

服务端推送是一种在客户端请求之前发送数据的机制。在HTTP/2中，**服务器可以对客户端的一个请求发送多个响应**。Server Push让HTTP1.x时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主顶内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个HTML文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

![img](http://pcc.huitogo.club/851357dd35d753511d2f701f0bc0818a)