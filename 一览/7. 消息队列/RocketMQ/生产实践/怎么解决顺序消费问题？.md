在上面的技术架构介绍中，我们已经知道了 RocketMQ 在**主题上是无序的、它只有在队列层面才是保证有序** 的。



这又扯到两个概念——**普通顺序** 和 **严格顺序** 。

所谓普通顺序是指 消费者通过 同一个消费队列收到的消息是有顺序的 ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 Broker 重启情况下不会保证消息顺序性 (短暂时间) 。

所谓严格顺序是指 消费者收到的 所有消息 均是有顺序的。严格顺序消息 即使在异常情况下也会保证消息的顺序性 。



但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，Broker 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 binlog 同步。

一般而言，我们的 MQ 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。



那么，我们现在使用了 普通顺序模式 ，我们从上面学习知道了在 Producer 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这三个消息会被发送到不同队列 ，因为在不同的队列此时就无法使用 RocketMQ 带来的队列有序特性来保证消息有序性了。

![img](http://pcc.huitogo.club/1925c0f131b3b48e8a23d932d879f9d3)



那么，怎么解决呢？



- **生产者有序**

其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 **Hash取模法** 来保证同一个订单的操作在同一个队列中就行了。



- **消息分区有序**

消息分区有序是由RocketMQ保证的，当一个 Topic 被划分为多个消息队列时，RocketMQ 提供了消息分区机制。在发送消息时，可以根据消息的关键字（Key）指定消息发送到特定的分区。然后，**每个分区只由一个消费者消费，从而保证了分区内消息的顺序性**。但是，不同分区之间的消息顺序无法保证。



- **消费者有序**

RocketMQ 提供了特殊的消费者类型，即顺序消息消费者（Orderly Message Consumer）。顺序消息消费者通过指定消费模式为 Orderly，来保证消息按照发生顺序进行消费。Orderly 模式下，RocketMQ 会将同一个消息队列中的消息按照顺序分发给同一个消费者线程，确保消息的顺序性。



需要注意的是，要保证消息的顺序消费，需要满足以下条件：

- 消费者订阅的是同一个 Topic。
- 消费者使用相同的消费者组（Consumer Group）。
- 消费者实例数量与 Topic 的消息队列数量相等，即每个消费者实例对应一个消息队列。
- 消费者采用顺序消息消费者（Orderly Message Consumer）模式。
  

还有一个问题，**顺序消息扩容的过程中，如何在不停写的情况下保证消息顺序？**

1. 成倍扩容，实现扩容前后，同样的 key，hash 到原队列，或者 hash 到新扩容的队列。
2. 扩容前，记录旧队列中的最大位点。
3. 对于每个 Consumer Group ，保证旧队列中的数据消费完，再消费新队列，也即：先对新队列进行禁读即可。