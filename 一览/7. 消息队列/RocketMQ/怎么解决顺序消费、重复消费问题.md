#### 1. 顺序消费

在上面的技术架构介绍中，我们已经知道了 RocketMQ 在**主题上是无序的、它只有在队列层面才是保证有序** 的。



这又扯到两个概念——**普通顺序** 和 **严格顺序** 。

所谓普通顺序是指 消费者通过 同一个消费队列收到的消息是有顺序的 ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 Broker 重启情况下不会保证消息顺序性 (短暂时间) 。

所谓严格顺序是指 消费者收到的 所有消息 均是有顺序的。严格顺序消息 即使在异常情况下也会保证消息的顺序性 。



但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，Broker 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 binlog 同步。

一般而言，我们的 MQ 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。



那么，我们现在使用了 普通顺序模式 ，我们从上面学习知道了在 Producer 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 三个消息会被发送到不同队列 ，因为在不同的队列此时就无法使用 RocketMQ 带来的队列有序特性来保证消息有序性了。

![img](http://pcc.huitogo.club/1925c0f131b3b48e8a23d932d879f9d3)



那么，怎么解决呢？



其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 **Hash取模法** 来保证同一个订单的操作在同一个队列中就行了。



#### 2. 重复消费

这个对于所有的消息队列来说都是用幂等的方式解决，因为你要保证消息不丢失的情况下必然会出现重复发送消息的行为，所以需要消费端去实现幂等的操作。



保证操作的幂等性常用的几个方法：

1. 使用数据库表的唯一键进行滤重，拒绝重复的请求
2. 使用分布式表对请求进行滤重
3. 使用状态流转的方向性来滤重，通常使用行级锁来实现(后续在锁相关的文章中详细说明)
4. 根据业务的特点，操作本身就是幂等的，例如：删除一个资源、增加一个资源、获得一个资源等