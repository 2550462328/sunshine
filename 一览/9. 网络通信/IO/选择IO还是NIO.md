**1. 面向流和面向缓冲**

**IO是面向流的，NIO是面向缓冲区的**。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。

Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。



**2. 阻塞和非阻塞**

**IO的各种流是阻塞的**。这意味着，当一个线程调用read() 或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。

**Java NIO的非阻塞模式**，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而**不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情**。

非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。

线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。



**3. NIO有选择器**

NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。



**4. 设计缺点**

**IO从一个阻塞的流中读数据**

```
1.  BufferedReader reader = new BufferedReader(new InputStreamReader(input));  

2.  String nameLine   = reader.readLine();  

3.  String ageLine    = reader.readLine();  

4.  String emailLine  = reader.readLine();  

5.  String phoneLine  = reader.readLine(); 
```

处理状态由程序执行多久决定。换句话说，一旦reader.readLine()方法返回，你就知道肯定文本行就已读完，readline()阻塞直到整行读完，这就是原因。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据。



**NIO从一个通道里读数据，直到所有的数据都读到缓冲区里**

```
1.  ByteBuffer buffer = ByteBuffer.allocate(48);  

2.  int bytesRead = inChannel.read(buffer);  
```

注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。

所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你**必须检查几次缓冲区的数据**。这不仅效率低下，而且可以使程序设计方案杂乱不堪。



**因为是非阻塞的，所以对异步返回的任何数据都要多次检查，包括接收连接和关闭连接。**



**5. 如何选择NIO和IO呢？**

**利用NIO单线程管理多个连接（非阻塞）**

如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。

**利用IO的一个连接通过一个线程处理（阻塞）**

如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。