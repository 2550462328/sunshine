从JAVA的使用上IO有

- BIO
- NIO
- AIO



但是**Java中提供的IO有关的API，在文件处理的时候，其实依赖操作系统层面的IO操作实现的。**

比如在Linux2.6以后，Java中NIO和AIO都是通过epoll来实现的，而在Windows上，AIO是通过IOCP来实现的。

在linux层面上有五种IO模型，分别是阻塞IO模型、非阻塞IO模型、信号先驱IO模型、IO复用模型和异步IO模型。



**到底什么是IO呢？**

![img](http://pcc.huitogo.club/906f1d0ec30c9139976c93a666aa6450)

一次IO操作可以联想成一次钓鱼的场景，这里面的鱼塘就可以映射成磁盘，中间过渡的鱼钩可以映射成内核空间，最终放鱼的鱼篓可以映射成用户空间。一次完整的钓鱼（IO）操作，是鱼（文件）从鱼塘（硬盘）中转移（拷贝）到鱼篓（用户空间）的过程。真正的文件读取还涉及到缓存等细节。



接下来讲解五大IO模型

### 1. IO阻塞模型

可以想象成我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。

类比到Linux操作系统一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。



![img](http://pcc.huitogo.club/b0a5be5c9df11933cef6eca0b92de4c3)



应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。

这种钓鱼方式相对来说比较简单，对于钓鱼的人来说，不需要什么特制的鱼竿，拿一根够长的木棍就可以悠闲的开始钓鱼了（实现简单）。缺点就是比较耗费时间，比较适合那种对鱼的需求量小的情况（并发低，时效性要求低）。



### 2. 非阻塞IO模型

基于以上钓鱼方式，我们完全可以在等鱼咬钩的时候可以做点别的事，但是我们要时不时的去看一下鱼竿，一旦发现有鱼儿上钩了，就把鱼钓上来。这就是非阻塞IO模型。

映射到Linux操作系统中，应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。



![img](http://pcc.huitogo.club/774aecaeaa3e350fc19e270beca84219)



应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间段，进程可以先做别的事情。

这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。



### 3. 信号先驱IO模型

对于以上钓鱼方式，我们还得时不时的去看一下有没有鱼上钩，也是不省心的事情，可不可以像烧开水一样，水开了就响提醒我去倒开水呢？这就是信号先驱IO模型

映射到Linux操作系统中，应用进程在读取文件时通知内核，如果某个 socket的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。



![img](http://pcc.huitogo.club/7340f04ee37eba2986866ac63e1db2ce)



应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。

这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。



### 4. IO复用模型

以上的钓鱼方式已经大大解决了钓鱼时需要守着鱼竿的问题，但是如果我想要弄多个鱼竿呢？那鱼来了怎么通知我是哪个鱼竿有鱼上钩呢？这就是IO复用模型

映射到Linux操作系统中，多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。



![img](http://pcc.huitogo.club/a8f4737630b8907dc457952186127c5c)



IO多路转接是多了一个select函数，多个进程的IO可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，select调用进程会阻塞。当任意一个IO所需的数据准备好之后，select调用就会返回，然后进程在通过recvfrom来进行数据拷贝。



这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。进程在发出select后，要等到select监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。

这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。



在介绍最后一个IO模型之前，我们先思考一下以上出场的四种钓鱼方式，有真正异步的钓鱼方式吗？

首先揭示答案，一个都没有！



什么是异步，异步是你想要做一件事，你不用刻意等它，你可以去吃个饭，等回来的时候它已经做好了，你直接拿着用就好了。

那么回到钓鱼上，有人说信号先驱IO模型不算异步吗？这边数据报准备好后就会通知你，咦~是不是突然反应过来，它只是通知你而已，人家鱼还在鱼塘里呢，你还得提一下钩子把它钓起来，所以当然不算异步了。我们只能说这种钓鱼方式的话等鱼上钩阶段是异步的，而钓上鱼依然是同步的。



那么有真正的异步IO模型吗？



### 5. 异步IO模型

基于以上想法，我们需要一款自动感应鱼上钩情况，自动将鱼放到桶里去，然后通知我们一声“老板搞定了”的产品，于是异步IO模型应景而生。

映射到Linux操作系统中，应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。



![img](http://pcc.huitogo.club/0a53ffa326db3d6e8fabfc7870d5689f)



用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。

这种方式的钓鱼，无疑是最省事儿的。啥都不需要管，只需要交给鱼竿就可以了。



最后我们来总结一下五种IO模型的情况



![img](http://pcc.huitogo.club/3074ac79e27b2bd60a25c1a20b084da6)



那么我们Java层面的三个IO使用的是哪种就不言而喻了吧

BIO ---> 阻塞式IO模型

NIO ---> IO复用模型

AIO ---> 异步IO模型

换句话说，BIO里用户最关心“我要读”，NIO里用户最关心"我可以读了"，在AIO模型里用户更需要关注的是“读完了”。