#### 1. dubbo服务组件

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201011011947309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTAyOTI4Ng==,size_16,color_FFFFFF,t_70#pic_center)

- Provider: 暴露服务的服务提供方

- Protocol 负责提供者和消费者之间协议交互数据

- Service 真实的业务服务信息 可以理解成接口 和 实现

- Container Dubbo的运行环境

- Consumer: 调用远程服务的服务消费方

- Protocol 负责提供者和消费者之间协议交互数据

- Cluster 感知提供者端的列表信息

- Proxy 可以理解成 提供者的服务调用代理类 由它接管 Consumer中的接口调用逻辑

- Registry: 注册中心，用于作为服务发现和路由配置等工作，提供者和消费者都会在这里进行注册

- Monitor: 用于提供者和消费者中的数据统计，比如调用频次，成功失败次数等信息。

  

#### 2. dubbo工作流程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201011011947309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTAyOTI4Ng==,size_16,color_FFFFFF,t_70#pic_center)

1. 提供者端启动 容器负责把Service信息加载 并通过Protocol 注册到注册中心
2. 消费者端启动 通过监听提供者列表来感知提供者信息 并在提供者发生改变时 通过注册中心及时 通知消费端
3. 消费方发起请求 通过Proxy模块
4. 利用Cluster模块 来选择真实的要发送给的提供者信息
5. 交由Consumer中的Protocol 把信息发送给提供者
6. 提供者同样需要通过 Protocol 模块来处理消费者的信息
7. 最后由真正的服务提供者 Service 来进行处理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201011151807739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTAyOTI4Ng==,size_16,color_FFFFFF,t_70#pic_center)

调用链路：淡绿色代表了 服务生产者的范围 淡蓝色 代表了服务消费者的范围 红色箭头代表了调用的方向

1. 消费者通过Interface进行方法调用 统一交由消费者端的 Proxy 通过ProxyFactory 来进行代理 对象的创建 使用到了 jdk javassist技术
2. 交给Filter 这个模块 做一个统一的过滤请求
3. 接下来会进入最主要的Invoker调用逻辑
4. 通过Directory 去配置中新读取信息 最终通过list方法获取所有的Invoker
5. 通过Cluster模块 根据选择的具体路由规则 来选取Invoker列表
6. 通过LoadBalance模块 根据负载均衡策略 选择一个具体的Invoker 来处理我们的请求
7. 如果执行中出现错误 并且Consumer阶段配置了重试机制 则会重新尝试执行
8. 继续经过Filter 进行执行功能的前后封装 Invoker 选择具体的执行协议
9. 客户端 进行编码和序列化 然后发送数据
10. 到达Provider中的 Server 在这里进行 反编码 和 反序列化的接收数据
11. 使用Exporter选择执行器
12. 交给Filter 进行一个提供者端的过滤 到达 Invoker 执行器
13. 通过Invoker 调用接口的具体实现 然后返回



dubbo启动后会在zookeeper下生成一个dubbo的子目录，dubbo下面是当前的接口名称

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012175808808.png#pic_center)



接口下面的四格配置项是

- consumers: 当前服务下面所有的消费者列表(URL)
- providers: 当前服务下面所有的提供者列表(URL)
- configuration: 当前服务下面的配置信息信息，provider或者consumer会通过读取这里的配 置信息来获取配置
- routers: 当消费者在进行获取提供者的时，会通过这里配置好的路由来进行适配匹配规则。

可以看到，dubbo基本上很多时候都是通过URL的形式来进行交互获取数据的，在URL中也会保存 很多的信息



#### 3. dubbo 服务层级

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012174701836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTAyOTI4Ng==,size_16,color_FFFFFF,t_70#pic_center)

- Business 业务逻辑层

  **service** 业务层 包括我们的业务代码 比如 接口 实现类 直接面向开发者

- RPC层 远程过程调用层

  **config** 配置层 对外提供配置 以ServiceConfig ReferenceConfig 为核心 可以直接初始化配置 类 也可以解析配置文件生成

  proxy 服务代理层 无论是生产者 还是消费者 框架都会产生一个代理类 整个过程对上层透明 就是 业务层对远程调用无感

  **registry** 注册中心层 封装服务地址的注册与发现 以服务的URL为中心

  **cluster** 路由层 (集群容错层) 提供了多个提供者的路由和负载均衡 并且它桥接注册中心 以Invoker为核心

  **monitor** 监控层 RPC调用相关的信息 如 调用次数 成功失败的情况 调用时间等 在这一层完成

  **protocol** 远程调用层 封装RPC调用 无论是服务的暴露 还是 服务的引用 都是在Protocol中作为主 功能入口 负责Invoker的整个生命周期 Dubbo中所有的模型都向Invoker靠拢

- Remoting层 远程数据传输层

  **exchange** 信息交换层 封装请求和响应的模式 如把请求由同步 转换成异步

  **transport** 网络传输层 统一网络传输的接口 比如 netty 和 mina 统一为一个网络传输接口

  **serialize** 数据序列化层 负责管理整个框架中的数据传输的序列化 和反序列化

  

#### 4. 答疑

**Q1：注册中心挂了可以继续通信吗？**

在实际生产中，假如zookeeper注册中心宕掉，**一段时间内服务消费方还是能够调用提供方的服务的**，实际上它使用的**本地缓存**进行通讯，这只是dubbo健壮性的一种体现。



**Q2：dubbo的健壮性表现为**？

1. 监控中心宕掉不影响使用，只是丢失部分采样数据
2. 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
3. 注册中心对等集群，任意一台宕掉后，将自动切换到另一台
4. 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
5. 服务提供者无状态，任意一台宕掉后，不影响使用
6. 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复