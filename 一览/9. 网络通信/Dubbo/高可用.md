#### 1. 消费端负载均衡策略

即消费者具体找哪个生产者请求服务

- **RandomLoadBalance**

默认情况下，dubbo 是 RandomLoadBalance ，即**随机**调用实现负载均衡，可以对 provider 不同实例**设置不同的权重**，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。



- **RoundRobinLoadBalance**

这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。



- **LeastActiveLoadBalance**

官网对 `LeastActiveLoadBalance` 的解释是“**最小活跃数负载均衡**”，活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求，那么此时请求会优先分配给该服务提供者。

最小活跃数负载均衡算法的基本思想是这样的：

每个服务提供者会对应着一个活跃数 `active`。初始情况下，所有服务提供者的 `active` 均为 0。每当收到一个请求，对应的服务提供者的 `active` 会加 1，处理完请求后，`active` 会减 1。所以，如果服务提供者性能较好，处理请求的效率就越高，那么 `active` 也会下降的越快。因此可以给这样的服务提供者优先分配请求。

当然，除了最小活跃数，`LeastActiveLoadBalance` 在实现上还引入了权重值。所以准确的来说，`LeastActiveLoadBalance` 是基于加权最小活跃数算法实现的。



- **ConsistentHashLoadBalance**

一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。**如果你需要的不是随机负载均衡**，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。



#### 2. 消费端集群容错策略

即消费者请求生产者服务失败后应该怎么做

- **Failover Cluster 模式**

失败自动切换，自动重试其他机器，**默认**就是这个，常见于读操作。（失败重试其它机器）

可以通过以下几种方式配置重试次数：

```xml
<dubbo:service retries="2" />Copy to clipboardErrorCopied
```

或者

```xml
<dubbo:reference retries="2" />Copy to clipboardErrorCopied
```

或者

```xml
<dubbo:reference>
    <dubbo:method name="findFoo" retries="2" />
</dubbo:reference>Copy to clipboardErrorCopied
```



- **Failfast Cluster 模式**

一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）



- **Failsafe Cluster 模式**

出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。

配置示例如下：

```xml
<dubbo:service cluster="failsafe" />Copy to clipboardErrorCopied
```

或者

```xml
<dubbo:reference cluster="failsafe" />Copy to clipboardErrorCopied
```



- **Failback Cluster 模式**

失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。



- **Forking Cluster 模式**

**并行调用**多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源，可通过 `forks="2"` 来设置最大并行数。



- **Broadcast Cluster 模式**

逐个调用所有的 provider。任何一个 provider 出错则报错（从 `2.1.0` 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。



#### 3. 动态代理策略

即消费者和提供者互动的实际请求行为

默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。