#### 1. 消息的粘包黏包问题

问题描述：TCP协议是流协议，服务器端发送数据 ABC DEF，客户端解析成AB DE F或者其他格式，如果不做处理的话这种情况很容易出现。



详细原因

1. 应用程序write写入的字节大小大于套接字发送缓冲区的大小。
2. 进行MSS大小的TCP分段
3. 以太网帧的payload大于MTU进行IP分片



解决方案

**1）使用 Netty 自带的解码器**

1. LineBasedFrameDecoder : 发送端发送数据包的时候，每个数据包之间以换行符作为分隔，LineBasedFrameDecoder 的工作原理是它依次遍历 ByteBuf 中的可读字节，判断是否有换行符，然后进行相应的截取。

   DelimiterBasedFrameDecoder : 可以自定义分隔符解码器，LineBasedFrameDecoder 实际上是一种特殊的 DelimiterBasedFrameDecoder 解码器。

2. FixedLengthFrameDecoder: 固定长度解码器，它能够按照指定的长度对消息进行相应的拆包。

3. LengthFieldBasedFrameDecoder：



**2）自定义序列化编解码器**

在 Java 中自带的有实现 Serializable 接口来实现序列化，但由于它性能、安全性等原因一般情况下是不会被使用到的。

通常情况下，我们使用 Protostuff、Hessian2、json 序列方式比较多，另外还有一些序列化性能非常好的序列化方式也是很好的选择：



专门针对 Java 语言的：Kryo，FST 等等

跨语言的：Protostuff（基于 protobuf 发展而来），ProtoBuf，Thrift，Avro，MsgPack 等等



**3）推荐方案，将消息分成消息头和消息体，在消息头中包含消息长度的字段，然后进行业务逻辑的处理**



#### **2. Netty的数据通信**

通信方式大致分为三种：

1） 长连接不间断的进行连接，也就是服务端和客户端的通道一直处于开启状态

推荐场景：服务器性能比较好，客户端连接数量比较少。



2）一次性批量提交数据，采用短连接方式，也就是我们将数据保存在本地临时缓冲区或者临时表中，界当到达临时一次性批量提交，或者根据定时任务轮询提交

推荐场景：对实时性要求不高。



3）使用一种特殊的长连接，在指定的某一个时间，**服务器没有和客户端通信时断开连接，当客户端向服务端发送请求时再次建立连接**。这种场景需要考虑到



**如何在超时后关闭通道，关闭通道后如何再创建连接？**

注：通信是双向的，所以不是说一边关闭连接通道，另一边就不可以朝这边传递数据了。

1. 关闭通道：服务端和客户端在通道处理器上加上new ReadTimeoutHandler(5)，5分钟无通信自动关闭。
2. 创立连接：每次在通信之前判断连接是否为空或者未激活状态，如果不是就重新获取连接。



客户端在宕机时无需考虑，在机器重启后与服务器建立连接，服务器宕机时客户端怎么和服务端进行连接呢？

一般客户端会定时向服务端发送监听包监听服务端在线情况，时长一般是服务端休眠时间的两倍。



#### 3. netty的长连接和短连接

**默认netty连接都是长连接**，如何切换成短连接呢？

在server端每次发完消息后关闭和客户端的连接，即在操作结尾加上addListener关闭对客户端的通道，但是客户端发送过来的消息还是会接收到。

注：writeAndFlush操作会把数据写到tcp流里面 并发送到通道里面，单纯的write并不会被服务端读取数据