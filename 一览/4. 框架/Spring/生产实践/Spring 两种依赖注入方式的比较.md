 我们知道，Spring 对象属性的注入方式有两种：设值注入和构造注入。先看代码：

假设有个类为 People，该对象包含三个属性，name 和 school 还有 age，这些属性都有各自的 setter 和 getter 方法，还有一个包含这三个属性的构造方法。如果用 spring 来管理这个对象，那么有以下两种方式为 People 设置属性：



1.设值注入

```
<bean id="people" class="com.abc.People">
　　 <property name="name" value="张三" /> <!-- 设值注入 -->
　　 <property name="school" ref="school" /> <!-- 设值注入 -->
　　 <property name="age" value="20" type="int" />
</bean>
<bean id="school" class="com.abc.School" />
```



2.构造注入

```
<bean id="people" class="com.abc.People">
    <!-- 构造注入，index=0表示构造器的第一个参数 -->
　　 <constructor-arg index="0" value="张三"/> 
　　 <constructor-arg index="1" ref="school" /> <!-- 构造注入 -->
　　 <constructor-arg index="2" value="20" type="int" />
</bean>
<bean id="school" class="com.abc.School" />
```



那么，这两种注入方式有和区别呢？

**这两种依赖注入的方式，并没有绝对的好坏，只是适应的场景有所不同。**

设值注入有如下优点：

- 设值注入需要该 Bean 包含这些属性的 setter 方法
- 与传统的 JavaBean 的写法更相似，程序开发人员更容易理解、接收。通过 setter 方法设定依赖关系显得更加只管。
- 对于复杂的依赖关系，如果采用构造注入，会导致构造器国语臃肿，难以阅读。Spring 在创建 Bean 实例时，需要同时实例化器依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题
- 尤其是在某些属性可选的情况况下，多参数的构造器显得更加笨重



构造注入有以下优势：

- 构造注入需要该 Bean 包含带有这些属性的构造器
- 构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。例如，组件中其他依赖关系的注入，常常要依赖于 DataSrouce 的注入。采用构造注入，可以在代码中清晰的决定注入顺序。
- 对于依赖关系无需变化的 Bean，构造注入更有用处。因为没有 Setter 方法，所有的依赖关系全部在构造器内设定。因此，无需担心后续的代码对依赖关系产生破坏。
- 依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。



综述来说：

| 构造函数注入               | setter 注入                |
| :------------------------- | :------------------------- |
| 没有部分注入               | 有部分注入                 |
| 不会覆盖 setter 属性       | 会覆盖 setter 属性         |
| 任意修改都会创建一个新实例 | 任意修改不会创建一个新实例 |
| 适用于设置很多属性         | 适用于设置少量属性         |



**建议：采用以设值注入为主，构造注入为辅的注入策略。对于依赖关系无需变化的注入，尽量采用构造注入；而其他的依赖关系的注入，则考虑采用设值注入。**