#### 1. SpringBoot启动类

当SpringBoot应用启动的时候，就从主方法里面进行启动的

```
1. @SpringBootApplication 

2. public class SpringBoot02ConfigAutoconfigApplication { 

3.  

4.   public static void main(String[] args) { 

5.     SpringApplication.run(SpringBoot02ConfigAutoconfigApplication.class, args); 

6.   } 

7. } 
```



它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。



#### 2. @EnableAutoConfiguration的作用

它主要利用了一个EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。

```
1. @Import(EnableAutoConfigurationImportSelector.class) 

2. public @interface EnableAutoConfiguration  
```



#### 3. 那么导入了哪些组件呢？

我们来看EnableAutoConfigurationImportSelector这个类的父类AutoConfigurationImportSelector



这个类规定了一个方法叫selectImports这个方法，查看了selectImports这个方法里面的代码内容就能知道导入了哪些组件了。

```
1. public String[] selectImports(AnnotationMetadata annotationMetadata) { 

2.   if (!this.isEnabled(annotationMetadata)) { 

3.     return NO_IMPORTS; 

4.   } else { 

5.     try { 

6.       ... 

7.       List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 

8.       ... 

9.     } catch (IOException var6) { 

10.       throw new IllegalStateException(var6); 

11.     } 

12.   } 

13. } 

14.  

15. protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { 

16.   List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); 

17.  ... 

18. } 
```



如果允许@EnableAutoConfiguration的话，会从指定的路径加载资源



#### 4. 那么会得到什么资源？

它是扫描java jar包类路径下的“META-INF/spring.factories”这个文件

```
1. /** 

2. * The location to look for factories. 

3. * <p>Can be present in multiple JAR files. 

4. */ 

5. public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"; 
```



**那么扫描到的这些文件作用**：是把这个文件的urls拿到之后并把这些urls每一个遍历，最终把这些文件整成一个properties对象

```
1. public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) { 

2.   String factoryClassName = factoryClass.getName(); 

3.   try { 

4.     Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : 

5.         ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); 

6.     List<String> result = new ArrayList<String>(); 

7.     while (urls.hasMoreElements()) { 

8.       URL url = urls.nextElement(); 

9.       Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); 

10.       String factoryClassNames = properties.getProperty(factoryClassName); 

11.       result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); 

12.     } 

13.     return result; 

14.   } 

15.     ... 

16. } 
```



它是将文件下的指定factoryClassName相关的值放到List<String>中去并返回。



我们先看一下这个spring.factories文件长啥样

![img](http://pcc.huitogo.club/0fd1c8425fc1b82ef65b5ea085a2454a)



相当于一个属性文件，那么loadFactoryNames方法是根据哪个factoryClassName获取它的值呢？

```
1. protected Class<?> getSpringFactoriesLoaderFactoryClass() { 

2.   return EnableAutoConfiguration.class; 

3. } 
```



所以，**@EnableAutoConfiguration的目的就是将META-INF/spring.factories中跟org.springframework.boot.autoconfigure.EnableAutoConfiguration有关的类注入到Spring容器中。**



最后我们容器中会添加很多类，比如

![img](http://pcc.huitogo.club/a157d1ae277f35cedb76cabb9476bffa)



#### 5. 添加很多类到容器中是为了什么？

加入到容器中之后的作用就是**用它们来做自动配置**，这就是Springboot自动配置之源，也就是自动配置的开始，只有这些自动配置类进入到容器中以后，接下来这个自动配置类才开始进行启动。



#### 6. 那什么是自动配置？

简单说

![img](http://pcc.huitogo.club/d0819ccbe118f5c09c0e0e860f319fec)



就是这些配置文件怎么生效的！为什么你不用写配置文件或者配置代码了，因为人家SprintBoot自动给你配置了，懂了没？就是将这些配置文件里面的选项变成一个个Bean被我们所用。



#### 7. 如何自动配置

终于回到了我们的主题



这就是题5的答案，借助通过@EnableAutoConfiguration注入过来的那么多的类。我们随便打开一个文件看看它是怎么做的吧



比如我们常见的JpaRepositoriesAutoConfiguration

```
1. @Configuration 

2. @ConditionalOnBean(DataSource.class) 

3. @ConditionalOnClass(JpaRepository.class) 

4. @ConditionalOnMissingBean({ JpaRepositoryFactoryBean.class, 

5.     JpaRepositoryConfigExtension.class }) 

6. @ConditionalOnProperty(prefix = "spring.data.jpa.repositories", name = "enabled", havingValue = "true", matchIfMissing = true) 

7. @Import(JpaRepositoriesAutoConfigureRegistrar.class) 

8. @AutoConfigureAfter(HibernateJpaAutoConfiguration.class) 

9. public class JpaRepositoriesAutoConfiguration { 

10.  

11. } 
```



可以看出如果让这个Bean生效，它需要

1. Spring容器中有DataSource
2. class环境中有JpaRepository.class
3. 配置文件的spring.data.jpa.repositories.enabled 必须是true
4. Spring容器中没有我们自己定义的JpaRepositoryFactoryBean和JpaRepositoryConfigExtension，这就表示我们自定义的Jpa配置类会替代这个默认的，比如我们使用了@EnableJpaRepositories注释，会导致当前失败
5. 它在HibernateJpaAutoConfiguration生效之后才生效



我们打开它引入的JpaRepositoriesAutoConfigureRegistrar类

```
1. /** 

2. * {@link ImportBeanDefinitionRegistrar} used to auto-configure Spring Data JPA 

3. * Repositories. 

4. */ 

5. class JpaRepositoriesAutoConfigureRegistrar 

6.     extends AbstractRepositoryConfigurationSourceSupport { 
```



所以JpaRepositoriesAutoConfiguration会在我们没有配置（@EnableJpaRepositories）下会默认帮我们自动配置Spring Data JPA Repositories



其他的*AutoConfiguration类都是类似的。