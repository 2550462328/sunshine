对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。

这就是缓存雪崩。

![redis-caching-avalanche](https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/redis-caching-avalanche.png)



缓存雪崩的事前事中事后的解决方案如下：

- 事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。

- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。

  当然，引入本地缓存也会有相应的问题，例如说：

  - 本地缓存的实时性怎么保证？
    - 方案一，可以引入消息队列。在数据更新时，发布数据更新的消息；而进程中有相应的消费者消费该消息，从而更新本地缓存。
    - 方案二，设置较短的过期时间，请求时从 DB 重新拉取。
    - 方案三，手动过期。
  - 每个进程可能会本地缓存相同的数据，导致数据浪费？
    - 方案一，需要配置本地缓存的过期策略和缓存数量上限。

  > ps：如果我们使用 JVM ，则可以使用 Ehcache、Guava Cache 实现本地缓存的功能，使用 Guava RateLimiter、Sentinel、Hystrix 实现限流的功能。

- 事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

![redis-caching-avalanche-solution](https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/redis-caching-avalanche-solution.png)

用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 Redis。如果 ehcache 和 Redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 Redis 中。

限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？**走降级**！可以返回一些默认的值，或者友情提示，或者空值。

好处：

- 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。
- 只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。
- 只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了。