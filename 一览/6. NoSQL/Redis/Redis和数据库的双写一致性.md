一致性问题是分布式常见问题，还可以再分为**最终一致性**和**强一致性**。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是**如果对数据有强一致性要求，不能放缓存**。我们所做的一切，只能保证最终一致性。另外，**我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免**。因此，有强一致性要求的数据，不能放缓存。



下面是解决问题的几种思路



#### 1. **设置过期时间**

我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存



#### 2. 读请求和写请求串行化

一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统**不是严格要求** “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：**读请求和写请求串行化**，串到一个**内存队列**里去。

串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。



#### 3. 先更新数据库，再更新缓存

这个方案可行性很低，原因有二

1）线程安全角度

同时有请求A和请求B进行更新操作，那么会出现：

```
线程A更新了数据库；

线程B更新了数据库；

线程B更新了缓存；

线程A更新了缓存；
```

这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑！



2）业务场景角度

很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。

比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。

另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于**比较复杂的缓存数据计算的场景**，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，**这个缓存到底会不会被频繁访问到？**



举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有**大量的冷数据**。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。**用到缓存才去算缓存。**

其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。



#### 4. 先删缓存，再更新数据库

先说一下这种方案可能会产生问题的原因？

```
请求A进行写操作，删除缓存；

请求B查询发现缓存不存在；

请求B去数据库查询得到旧值；

请求B将旧值写入缓存；

请求A将新值写入数据库；
```

上述步骤中B在缓存中生成的旧值如果没有设置过期时间的话就会变成脏数据



解决步骤

**使用两次删除**

就是请求A再将新值写入数据库之后停留几百毫秒（确保请求B已经执行完毕），再一次删除缓存里面的值。

伪代码如下：

```
1.  public void write(String key, Object data){  

2.     redis.del(key);  

3.     db.updateData(data);  

4.     Thread.sleep(1000);  

5.     redis.del(key);  

6.  }  
```



**如果是在读写分离的情况下怎么处理？**

读写分离会产生问题的地方和上面类似

请求A更新的内容还没有同步到读库，然后请求B拿到了读库里面的旧值，从而在缓存中产生了脏数据。

解决办法也可以和上面一样采用两次删除的办法，但是线程等待的时间需要考虑一下读写库同步的时间。



**每次write的时候都要等几百毫秒，系统吞吐量下降了怎么办？**

在请求A更新完数据后，等待和再次删除的过程可以另起一个线程异步执行，让主线程直接返回。



#### 6. Cache Aside Pattern

最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。



在系统正常运行的情况下几乎不存在问题，如果找极端条件的话，就是下面这种情况

```
缓存刚好失效了

请求B请求数据，从数据库里面获取旧值

请求A更新了数据库，写入了新值

请求A删除了缓存

请求B将旧值加入了缓存
```

这种情况的前提条件就是请求A写入数据库的速度比请求B读取数据库的速度要快，当然这是不太可能的。



如果出现这种问题的话

1. 给缓存设置有效时间
2. 采用方法3中的异步延时删除法



下面讨论删除缓存失败的极端问题

##### 6.1 删除缓存失败

问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。

![redis-junior-inconsistent](https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/redis-junior-inconsistent.png)

解决思路 1：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。



解决思路 2：延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。

```java
public void set(key, value) {
    putToDb(key, value);
    deleteFromRedis(key);

    // ... a few seconds later
    deleteFromRedis(key);
}
```



删除的动作，可以有多种选择，比如：1. 使用 `DelayQueue`，会随着 JVM 进程的死亡，丢失更新的风险；2. 放在 `MQ`，但编码复杂度为增加。总之，我们需要综合各种因素去做设计，选择一个最合理的解决方案。



##### 6.2 思路1并发问题

解决思路 1是先删除缓存，再更新数据库

数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，**查到了修改前的旧数据**，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了...



**为什么上亿流量高并发场景下，缓存会出现这个问题？**

只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就**可能会出现上述的数据库+缓存不一致的情况**。



**解决方案如下：**

更新数据的时候，根据**数据的唯一标识**，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。

一个队列对应一个工作线程，每个工作线程**串行**拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。

这里有一个**优化点**，一个队列中，其实**多个更新缓存请求串在一起是没意义的**，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。

待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。

如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。



##### 6.3 异步延时删除失败

需要提供一个保障的重试机制

1）使用消息队列

使用消息队列存放删除失败的key，流程如下所示

![img](http://pcc.huitogo.club/9f071b85ade46395efd39aeb03640735)

流程如上所示，这种方案造成的缺点就是对业务代码会造成入侵，需要在业务代码中去处理异常的情况。



2）订阅数据库的binlog

启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作，流程如下所示

![img](http://pcc.huitogo.club/4895833fcd71e53722b7e89eb2342edc)

这种方式相当于将方案一中的处理流程从业务代码中分离出来



**如何订阅数据库的binlog？**

在mysql中有现成的中间件叫**canal**，可以完成订阅binlog日志的功能