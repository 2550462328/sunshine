#### 1. 统计redis的内存信息

redis-cli连接上redis客户端后使用info memory指令可以查看内存信息，如下

![img](http://pcc.huitogo.club/aefbd7c63abd08e767b0f3b5f1eb1ff7)



其中

- used_memory

Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；

used_memory_human只是显示更友好。



- used_memory_rss

Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了**分配器分配的内存**之外，used_memory_rss还包括**进程运行本身需要的内存**、**内存碎片**等，但是**不包括虚拟内存**。

used_memory是从redis角度得到的量，used_memory_rss是从操作系统角度得到的量

在实际应用中，redis数据量很大，所以used_memory_rss中的进程运行本身需要的内存和used_memory中的虚拟内存可以忽略不计，因此将（used_memory_rss/used_memory）的比例作为衡量内存碎片的标准。



- mem_fragmentation_ratio

内存碎片比率，该值是used_memory_rss / used_memory的比值

mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。

mem_fragmentation_ratio<1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。

一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）



- mem_allocator

Redis使用的内存分配器，在编译时指定；可以是 libc、jemalloc或者tcmalloc，默认是**jemalloc**；



#### 2. Redis内存占用的组成部分

1）数据

作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。

需要注意的是Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；



2）进程本身运行的内存

Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存不是由jemalloc分配，因此不会统计在used_memory中。

Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。



3）缓冲内存

客户端缓冲区：客户端缓冲存储客户端连接的输入输出缓冲

复制积压缓冲区：复制积压缓冲用于部分复制功能

AOF缓冲区：AOF缓冲区用于在进行AOF重写时，保存最近的写入命令

这部分内存由jemalloc分配，因此会统计在used_memory中。



**4）内存碎片**

内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。

内存碎片的产生与对数据进行的操作、数据的特点等都有关；此外，与使用的内存分配器也有关系：如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。

如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。



#### 3. Redis是怎么存储的？

这里以简单的set key value为例子

下图是执行set hello world时所涉及到的数据模型

![img](http://pcc.huitogo.club/f6c5a11b9e9dbda580d97436b8585054)



其中涉及到的有

1）dictEntry

Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry



2）sds

简单动态字符串，可以看出Key hello不是已字符串存储的，而是存储在sds结构中。



3）redisObject

不论Value是5种类型的哪一种，都是通过redisObject来存储的；

redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。



4）jemalloc

内存分配器，分配内存进行存储



下面详细进行介绍

##### 3.1 jemalloc

jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。



jemalloc划分的内存单元如下图所示：

![img](http://pcc.huitogo.club/bf50e4292aba1b77bd6c586ee1af1a40)

例如，如果需要存储大小为130字节的对象，jemalloc会将其放入160字节的内存单元中。



##### 3.2 redisObject

redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持。



redisObject定义如下：

![img](http://pcc.huitogo.club/43d6c388b7c645312a381b0706c29553)



其中各字段含义如下：

1）type

type字段表示对象的类型，占4个比特；

目前包括REDIS_STRING(字符串)、REDIS_LIST(列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。

在redis客户端执行type指令可以查看



2）encoding

encoding表示对象的内部编码，占4个比特。

对于Redis支持的每种类型，都有至少两种内部编码，通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。

比如链表有压缩列表和双端列表两种编码方式，当数据量较小的时候使用压缩列表来节省内存空间，当数据量较大的时候使用双端列表实现更快操作。

在redis客户端执行object encoding指令可以查看



3）lru

lru记录的是对象最后一次被命令程序访问的时间，占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。

lru可以用于内存淘汰策略，如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。

通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。



4）refcount

refcount记录的是该对象被引用的次数，大小是4字节。

refCount主要用于对象的引用计数和内存回收，当对象初始化时refCount为1，被新程序引用时加1，不被新程序引用时减1，当refCount为0时，这个对象就会被内存回收。

refCount大于1的对象叫做“**共享对象**”。也就是对象重复时，不会重复创建直接引用已有的对象，**目前共享对象仅支持整数型的字符串对象**。



**为什么共享对象仅支持字符串对象？**

这是对于内存和CPU的一次权衡，是否引用共享对象的时候会进行一次“相等判断”；对于整数型，判断复杂度是o(1)，对于普通字符串是o(n),对于哈希、列表、集合的复杂度是o(n^2)，所以目前整数型是最适合共享对象的。

在目前实现中，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0~9999的整数值；当Redis需要使用值为0~9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）

共享对象的引用次数可以通过object refcount命令查看。



5）ptr

ptr指针指向具体的数据，大小是8字节。

如前面的例子中，set hello world，ptr指向包含字符串world的SDS。

综上可知，在redis4.0的版本下，一个redisObjct占的内存是

4bit + 4bit + 24bit + 4B + 8B = 16B



##### 3.3 sds简单动态字符串

Redis没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。



sds定义如下：

![img](http://pcc.huitogo.club/b32f3f50c5a2f3dd6300ed37b4f1cf68)

其中buf表示字节数组，用来存储字符串；len表示buf已使用的长度，free表示buf未使用的长度。



从下图可以看到buf的长度是free + len + 1

所以sds的占据内存是 4 + 4 + free +len + 1 即free + len + 9

![img](http://pcc.huitogo.club/53cef73dafa73f602cd19a3953b4b339)



**为什么使用sds代替c字符串？**

1. **优化获取字符串长度**：SDS是O(1)，C字符串是O(n)
2. **解决缓冲区溢出**：使用C字符串的API时，如果字符串长度增加（如strcat操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而SDS由于记录了长度，相应的API在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。
3. **解决修改字符串时内存的重分配**：对于C字符串，如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于SDS，由于可以记录len和free，因此解除了字符串长度和空间数组长度之间的关联，可以在此基础上进行优化：空间预分配策略（即分配内存时比实际需要的多）使得字符串长度增大时重新分配内存的概率大大减小；惰性空间释放策略使得字符串长度减小时重新分配内存的概率大大减小。
4. **存取二进制数据**：SDS可以，C字符串不可以。因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而SDS以字符串长度len来作为字符串结束标识，因此没有这个问题。
5. **利用C字符串优点**：由于SDS中的buf仍然使用了C字符串（即以’\0’结尾），因此SDS可以使用C字符串库中的部分函数；



#### 4. redis的数据编码

Redis支持5种对象类型，而每种结构都有至少两种编码；这样做的好处在于：一方面接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响，另一方面可以根据不同的应用场景切换内部编码，提高效率。



redis对象类型对应的内部编码如下

![img](http://pcc.huitogo.club/95e8df4c954884bd272b4e11bcb9bd6b)

关于Redis内部编码的转换，都符合以下规律：**编码转换在Redis写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。**



##### 4.1 字符串

-  int

8个字节的长整型。字符串值是整型时，这个值使用long整型表示。

- embstr

<=44字节的字符串。（这个具体指看版本和操作系统）

- raw

大于44个字节的字符串



embstr和raw都使用redisObject和sds保存数据

embstr的使用**只分配一次内存空间**（因此redisObject和sds是连续的）

raw**需要分配两次内存空间**（分别为redisObject和sds分配空间）

embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。

当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。

对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，**只要是修改embstr对象，修改后的对象一定是raw的.**



##### 4.2 列表

- ziplist

压缩列表，压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂。

-  linkedlist

双端列表，由一个list结构和多个listNode结构组成，典型结构如下图所示：

![img](http://pcc.huitogo.club/4fa041423b8c5c9ddc4caba2de8bd1a9)



双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。

与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。

只有列表中元素数量小于512个且列表中所有字符串对象都不足64字节才可以使用压缩列表。

其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为压缩列表使用连续、定长内存块存储字符串，不需要SDS结构指明长度。



##### 4.3 哈希

哈希分为“外部的哈希”和“内部的哈希”

“内层的哈希”代表的是redis对外提供的5种对象类型的一种。

“外层的哈希”代指Redis作为Key-Value数据库所使用的数据结构。



“内层的哈希”使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的“外层的哈希”则只使用了hashtable。

这里zipList和列表中的作用一样，使用ziplist的前提是：

1. 哈希中元素数量小于512个
2. 哈希中所有键值对的键和值字符串长度都小于64字节。



重点看一下**hashtable**

hashtable：一个hashtable由1个dict结构、2个dictht结构、1个dictEntry指针数组（称为bucket）和多个dictEntry结构组成，结构图如下：

![img](http://pcc.huitogo.club/53c6386241364f42136bca1a18cc99fa)



1）dictEntry

结构定义如下：

![img](http://pcc.huitogo.club/91bf75594e39fe02f5bd47476fd8113d)



其中各属性

- key：键值对中的键；

- val：键值对中的值，使用union(即共用体)实现，存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型；

- next：指向下一个dictEntry，用于解决哈希冲突问题

在64位系统中，一个dictEntry对象占24字节（key/val/next各占8字节）。



2）bucket

bucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；



3）dictht

结构定义如下：

![img](http://pcc.huitogo.club/57dfb11933b48a95507cfee39d621a60)



其中各属性

- table：是一个指针，指向bucket；

- size：记录了哈希表的大小，即bucket的大小；

- used：记录了已使用的dictEntry的数量；

- sizemask：这个值总是为size-1，这个属性和哈希值一起决定一个键在table中存储的位置。



4）dict

一般来说，通过使用dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。

dict的结构定义如下：

![img](http://pcc.huitogo.club/83626aa9d80facca870548cc8834c122)



type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典。

ht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。

因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，一方面是为了适应不同类型的键值对，另一方面是为了rehash。



##### 4.4 集合

集合的内部编码可以是整数集合（intset）或哈希表（hashtable）。

哈希表跟之前一样，只是集合使用哈希表的时候，value全部为空，跟java一样。



下面看一下**intset**，结构定义如下：

![img](http://pcc.huitogo.club/55e9d833d822ec88b229f3589fbb99b5)



其中各属性

- encoding：代表contents中存储内容的类型，虽然contents（存储集合中的元素）是int8_t类型，但实际上其存储的值是int16_t、int32_t或int64_t，具体的类型便是由encoding决定的

- length：表示元素个数。



**整数集合适用于集合所有元素都是整数且集合元素数量较小的时候**，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于集合数量较少，因此操作的时间并没有明显劣势。

整数集合使用条件

1. 集合中元素数量小于512个
2. 集合中所有元素都是整数值



##### 4.5 有序集合

有序集合的内部编码可以是压缩列表（ziplist）或跳跃表（skiplist）。

压缩列表的使用条件

1. 有序集合中元素数量小于128个
2. 有序集合中所有成员长度都不足64字节



这里着重看一下**skiplist**

跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。

跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。

Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。



#### 5. redis的内存应用

##### 5.1 估算Redis内存使用量

假设有90000个键值对，每个key的长度是7个字节，每个value的长度也是7个字节（且key和value都不是整数）；下面来估算这90000个键值对所占用的空间。



首先可以确定的是字符串类型使用的编码方式是embstr。

90000个键值对占据的内存空间主要可以分为两部分：一部分是90000个dictEntry占据的空间；一部分是键值对所需要的bucket空间。



一个dictEntry占据的空间是

- 　 一个dictEntry，24字节，jemalloc会分配32字节的内存块;
- 　一个key，7字节，所以SDS(key)需要7+9=16个字节，jemalloc会分配16字节 的内存块;
- 　一个redisObject，16字节，jemalloc会分配16字节的内存块;
- 　一个value，7字节，所以SDS(value)需要7+9=16个字节，jemalloc会分配16字节的内存块;



综上，一个dictEntry需要32 + 16 + 16 + 16 = 80个字节;

bucket空间：bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节）。

所以90000个元素占据内存大小为：90000*80 + 131072*8 = 8248576



##### 5.2 优化内存占用

1）利用jemalloc特性进行优化

由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。

例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。



2）使用整型/长整型

如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。



3）使用共享对象

利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。

可以适当调整REDIS_SHARED_INTEGERS参数提高共享对象的个数。

考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。



4）避免过度设计

不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。

如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。



##### 5.3 关注内存碎片率

如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。

如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。

以上是关注内存进数据，此外还需要关注内存出数据，也就是**关注数据回收策略**，根据不同优先级对内存进行回收。