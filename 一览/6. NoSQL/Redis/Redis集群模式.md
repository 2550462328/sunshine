#### 1. Redis cluster 介绍

![img](http://pcc.huitogo.club/7d067e9642c4abded490fd2c8800bbf5)

集群中的每一个 Redis 节点都 **互相两两相连**，客户端任意 **直连** 到集群中的 **任意一台**，就可以对其他 Redis 节点进行 **读写** 的操作。



集群的主要作用

1. **数据分区**： 数据分区 (或称数据分片) 是集群最核心的功能。集群将数据分散到多个节点，一方面 **突破了 Redis 单机内存大小的限制，存储容量大大增加**；另一方面 每个主节点都可以对外提供读服务和写服务，**大大提高了集群的响应能力**。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，bgsave 和 bgrewriteaof 的 fork 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……
2. **高可用**： 集群支持主从复制和主节点的 **自动故障转移** （与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。



Redis cluster，主要是针对**海量数据+高并发+高可用**的场景。Redis cluster 支撑 N 个 Redis master node，每个 master node 都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。



#### 2. 集群搭建

配置需要集群的节点

```
1. # 后台执行 

2. daemonize yes 

3. # 端口号 

4. port 7000 

5. # 为每一个集群节点指定一个 pid_file 

6. pidfile ~/Desktop/redis-cluster/redis_7000.pid 

7. # 启动集群模式 

8. cluster-enabled yes 

9. # 每一个集群节点都有一个配置文件，这个文件是不能手动编辑的。确保每一个集群节点的配置文件不通 

10. cluster-config-file nodes-7000.conf 

11. # 集群节点的超时时间，单位：ms，超时后集群会认为该节点失败 

12. cluster-node-timeout 5000 
```



手动连接需要集群的节点

```
1. redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 
```



这个 --replicas 1 的意思是：我们希望为集群中的每个主节点创建一个从节点。



我们可以使用 cluster info (查看集群信息) 和 cluster nodes (查看节点列表) 来查看集群信息

```
1. 127.0.0.1:7001> CLUSTER INFO 

2. cluster_state:ok 

3. cluster_slots_assigned:16384 

4. cluster_slots_ok:16384 

5. cluster_slots_pfail:0 

6. cluster_slots_fail:0 

7. cluster_known_nodes:6 

8. cluster_size:3 

9. cluster_current_epoch:6 

10. cluster_my_epoch:2 

11. cluster_stats_messages_ping_sent:1365 

12. cluster_stats_messages_pong_sent:1358 

13. cluster_stats_messages_meet_sent:4 

14. cluster_stats_messages_sent:2727 

15. cluster_stats_messages_ping_received:1357 

16. cluster_stats_messages_pong_received:1369 

17. cluster_stats_messages_meet_received:1 

18. cluster_stats_messages_received:2727 

19.  

20. 127.0.0.1:7001> CLUSTER NODES 

21. 56a04742f36c6e84968cae871cd438935081e86f 127.0.0.1:7003@17003 slave 4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 0 1584428884000 4 connected 

22. 4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 127.0.0.1:7000@17000 master - 0 1584428884000 1 connected 0-5460 

23. e2539c4398b8258d3f9ffa714bd778da107cb2cd 127.0.0.1:7005@17005 slave a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 0 1584428885222 6 connected 

24. d31cd1f423ab1e1849cac01ae927e4b6950f55d9 127.0.0.1:7004@17004 slave 236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 0 1584428884209 5 connected 

25. 236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 127.0.0.1:7001@17001 myself,master - 0 1584428882000 2 connected 5461-10922 

26. a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 127.0.0.1:7002@17002 master - 0 1584428884000 3 connected 10923-16383 

27. 127.0.0.1:7001> 
```



#### 3. 集群通信

在 哨兵系统 中，节点分为 数据节点 和 哨兵节点：前者存储数据，后者实现额外的控制功能。在 集群 中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。为此，**集群中的每个节点，都提供了两个 TCP 端口**：

1. 普通端口： 即我们在前面指定的端口 (7000等)。普通端口主要用于为客户端提供服务 （与单机节点类似）；但在节点间数据迁移时也会使用。
2. 集群端口： 端口号是普通端口 + 10000 （10000是固定值，无法改变），如 7000 节点的集群端口为 17000。**集群端口只用于节点之间的通信**，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。



节点间通信，按照**通信协议可以分为几种类型**：单对单、**广播**、**Gossip 协议**等。重点是**广播和 Gossip 的对比**。

1. 广播是指向集群内所有节点发送消息。优点 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。
2. Gossip 协议的特点是：在节点数量有限的网络中，每个节点都 “随机” 的与部分节点通信 （并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 优点 有负载 (比广播) 低、去中心化、容错性高 (因为通信有冗余) 等；缺点 主要是集群的收敛速度慢。



Redis 维护集群元数据采用 `gossip` 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。

![Redis-gossip](https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/redis-gossip.png)



使用gossip协议通信的好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。



##### 3.1 集群间通信的消息类型

集群中的节点采用 **固定频率（每秒10次）** 的 **定时任务** 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。



节点间发送的消息主要分为 5 种：**meet 消息、ping 消息、pong 消息、fail 消息、publish 消息**。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：

1. MEET 消息： 在节点握手阶段，当节点收到客户端的 CLUSTER MEET 命令时，会向新加入的节点发送 MEET 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 PONG 消息。
2. PING 消息： 集群里每个节点每秒钟会选择部分节点发送 PING 消息，接收者收到消息后会回复一个 PONG 消息。PING 消息的内容是自身节点和部分其他节点的状态信息，作用是彼此交换信息，以及检测节点是否在线。PING 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 PONG 消息时间大于 cluster_node_timeout / 2 的所有节点，防止这些节点长时间未更新。
3. PONG消息： PONG 消息封装了自身状态数据。可以分为两种：第一种 是在接到 MEET/PING 消息后回复的 PONG 消息；第二种 是指节点向集群广播 PONG 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 PONG 消息。
4. FAIL 消息： 当一个主节点判断另一个主节点进入 FAIL 状态时，会向集群广播这一 FAIL 消息；接收节点会将这一 FAIL 消息保存起来，便于后续的判断。
5. PUBLISH 消息： 节点收到 PUBLISH 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 PUBLISH 命令。



##### 3.2 集群的请求路由

当客户端连接集群时，会将集群的槽位配置信息缓存到客户端本地，这样客户端需要查询某个key时可以直接定位到目标节点。同时因为可能存在客户端和服务器存储的槽位信息不一致，所以还需要纠正机制来实现槽位的校验调整。



**1）MOVED重定向**

Redis接收任何键相关命令时首先计算键对应的槽位编号，再根据槽位找出所对应的节点，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，通知客户端请求正确的节点，这个过程称为MOVED重定向。重定向信息包含了键所对应的槽位以及负责该槽位的节点地址，根据这些信息客户端就可以向正确的节点发起请求。



客户端收到MOVED指令后，要**纠正本地的槽位映射表**。

![img](http://pcc.huitogo.club/e8afc6ee01a3f2af3e5abb65771a8d34)



3999为当前key所属槽位编号 后面的127.0.0.1:6381是目标节点B的地址



**2）ASK重定向**

当集群中发生扩缩容时会发生槽位迁移，比如当节点A正在把槽334迁移到节点B，那么在迁移完成之前，槽334的一部分数据存在节点A，一部分数据存在节点B。在迁移完成之前，集群中的所有节点都仍然会认为槽334由节点A负责。所以当访问槽334中的数据时，请求会被统一路由到节点A，如果A发现客户端访问的键并不在本地存储（可能已经被迁移到了节点B，或者该键之前就不存在），那么节点A就会向客户端返回ASK重定向。ASK重定向同样会返回槽值和节点B的地址，客户端会根据ASK返回的重定向地址向B发起请求。



对客户端来说，MOVED和ASK重定向的区别在于，**当客户端收到MOVED重定向时会更新本地的槽位映射表，但是接收到ASK重定向不会更新本地的槽位映射表。**



#### 4. 集群状态的数据结构

节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……



节点为了存储集群状态而提供的数据结构中，最关键的是 **clusterNode** 和 **clusterState** 结构：**前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。**



##### 4.1 clusterNode 结构

clusterNode 结构保存了 **一个节点的当前状态**，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 clusterNode 结构记录自己的状态，并为集群内所有其他节点都创建一个 clusterNode 结构来记录节点状态。



下面列举了 clusterNode 的部分字段，并说明了字段的含义和作用：

```
1. typedef struct clusterNode { 

2.   //节点创建时间 

3.   mstime_t ctime; 

4.   //节点id 

5.   char name[REDIS_CLUSTER_NAMELEN]; 

6.   //节点的ip和端口号 

7.   char ip[REDIS_IP_STR_LEN]; 

8.   int port; 

9.   //节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等 

10.   int flags; 

11.   //配置纪元：故障转移时起作用，类似于哨兵的配置纪元 

12.   uint64_t configEpoch; 

13.   //槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中 

14.   unsigned char slots[16384/8]; 

15.   //节点中槽的数量 

16.   int numslots; 

17.   ………… 

18. } clusterNode; 
```



除了上述字段，clusterNode 还包含节点连接、主从复制、故障发现和转移需要的信息等。





##### 4.2 clusterState 结构

clusterState 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：

```
1. typedef struct clusterState { 

2.   //自身节点 

3.   clusterNode *myself; 

4.   //配置纪元 

5.   uint64_t currentEpoch; 

6.   //集群状态：在线还是下线 

7.   int state; 

8.   //集群中至少包含一个槽的节点数量 

9.   int size; 

10.   //哈希表，节点名称->clusterNode节点指针 

11.   dict *nodes; 

12.   //槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL 

13.   clusterNode *slots[16384]; 

14.   ………… 

15. } clusterState; 
```



除此之外，clusterState 还包括故障转移、槽迁移等需要的信息。



#### 5. 主备切换

Redis cluster 的主备切换流程，几乎跟哨兵是类似的。

**判断节点宕机**

如果一个节点认为另外一个节点宕机，那么就是 `pfail` ，**主观宕机**。如果多个节点都认为另外一个节点宕机了，那么就是 `fail` ，**客观宕机**，跟哨兵的原理几乎一样，sdown，odown。

在 `cluster-node-timeout` 内，某个节点一直没有返回 `pong` ，那么就被认为 `pfail` 。

如果一个节点认为某个节点 `pfail` 了，那么会在 `gossip ping` 消息中， `ping` 给其他节点，如果**超过半数**的节点都认为 `pfail` 了，那么就会变成 `fail` 。



**从节点过滤**

对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。

检查每个 slave node 与 master node 断开连接的时间，如果超过了 `cluster-node-timeout * cluster-slave-validity-factor` ，那么就**没有资格**切换成 `master` 。



**从节点选举**

每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。

所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node `（N/2 + 1）` 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。

从节点执行主备切换，从节点切换为主节点。



#### 6. 集群模式优缺点

这种方式的优点：

1. 由于存在多个master，可以减小访问瞬断问题的影响：集群中有一个master挂了，正好需要向这个master写数据，这个操作需要等待一下；但是向其他master节点写数据是不受影响的。
2. Redis集群有多个master，可以提供更高的并发量
3. Redis集群可以分片存储，这样就可以存储更多的数据



缺点

1. 集群实现比较复杂；
2. 批量操作指令（ mget、mset 等）支持有限；
3. 事务操作支持有限。



