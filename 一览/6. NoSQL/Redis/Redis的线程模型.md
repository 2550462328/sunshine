
Redis 内部使用**文件事件处理器** file event handler ，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket ，根据 socket 上的事 件来选择对应的事件处理器进行处理。



文件事件处理器的结构包含 4 个部分：

1. 多个 socket 。
2. IO 多路复用程序。
3. 文件事件分派器。
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会 监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事 件，把该事件交给对应的事件处理器进行处理。



来看客户端与 Redis 的一次通信过程：

![img](http://pcc.huitogo.club/951a23ef191cd8235e8b68da44031d9c)



下面来大致说一下这个图：

1. 客户端 Socket01 向 Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列 中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个 能与客户端通信的 Socket01，并将该 Socket01 的 AE_READABLE 事件与命令请求处理器关 联。
2. 假设此时客户端发送了一个 set key value 请求，此时 Redis 中的 Socket01 会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事 件，由于前面 Socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器 将事件交给命令请求处理器来处理。命令请求处理器读取 Socket01 的 set key value 并在自己 内存中完成 set key value 的设置。操作完成后，它会将 Socket01 的 AE_WRITABLE 事件与令 回复处理器关联。
3. 如果此时客户端准备好接收返回结果了，那么 Redis 中的 Socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复 处理器对 Socket01 输入本次操作的一个结果，比如 ok ，之后解除 Socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。



**Redis 管道**

Redis 是基于请求／响应协议的 TCP 服务 。 在客户端 向 服务器发送一个查询请求后， 需要 监听 Socket 的返回，该监听过程一直阻塞 ， 直到服务器有结果返回 。 由于 Redis 集 群是部署在多个服务器上 的 ， 所以 Redis 的请求／响应模型在每次请求时都要跨 网 络在不 同的服务器之间传输数据 ， 这样每次查询都存在一定 的网络延迟（服务器之间的网络延 迟一般在 20ms 左右）。 由于服务器一般采用多线程处理业务，并且内存操作效率很高， 所以如果一次请求延迟 20ms ， 则多次请求的网络延迟会不断累加 。 也就是说，在分布式 环境下， **Redis 的性能瓶颈主要体现在网络延迟**上 。



Redis 请求／响应模型的数据请求 、响应流程如图所示

![img](http://pcc.huitogo.club/ddfedf5b2fae1f2c7d74e34169ac462c)



Redis 的管道技术指在服务端未响应时，客户端可以继续 向 服务端发送请求，并最终 一次性读取所有服务端的 响 应 。 管道技术 能减少客户端和服务器交互的次数，将客户端 的请求批量发送给服务器，服务器针对批量数据分别查询并统一 回复，能显著提高 Redis 的性能 。



Redis 管道模型的数据请求流程如图所示

![img](http://pcc.huitogo.club/f63e8a76dbc3907539c1440231fc03bc)