Redis 支持分布式环境下的事务操作，其事务可以一次执行多个命令，事务中的所有 命令都会序列化地顺序执行 。 事务在执行过程中，不会被其他客户端发送来 的命令请求 打断 。 服务器在执行完事务中的所有命令之后，才会继续处理其他客户端的其他命令 。

Redis 的事务操作分为开启事务、命令入队列 、执行事务 三个阶段 。



Redis 的事务执行流程如下， 如图所示

![img](http://pcc.huitogo.club/55a2da2172cad5f599be34be24c746b7)

1. 事务开启 ： 客户端执行 Multi 命令开启事务 。
2. 提交请求 ： 客户端提交命令到事务 。
3. 任务入队列 ： Redis 将客户端请求放入事务队列中等待执行 。
4. 入队状态反馈 ： 服务器返回 QURUD ，表示命令己被放人事务队列 。
5. 执行命令 ： 客户端通过 Exec 执行事务 。
6. 事务执行错误 ： 在 Redis 事务 中如果某条命令执行错误， 则其他命令会继续执 行，不会回滚 。 可以通过Watch 监控事务执行的状态并处理命令执行错误 的异常情况 。
7. 执行结果反馈 ：服务器 向 客户端返回 事务执行的结果。



Redis 事务 的相关命令有 Multi 、 Exec、 Discard 、 Watch 和 Unwatch

![img](http://pcc.huitogo.club/bc9d5c60e5155ac8834bd53d90667d61)



事务执行过程 MULTI -> 命令入列 -> EXEC



如果在命令入列时出错，那么整个事务都会被抛弃，如果在EXEC时出错，那么没有错误的命令会被执行，有错误的会返回异常（**事务不会回滚**）。

因为**回滚也解决不了因为编程错误带来的问题**，不支持回滚也会使Redis的内部保持简单和快速。



WATCH为Redis事务提供了CAS行为（check and set）。

WATCH的生命周期是WATCH 执行之后开始生效， 直到调用 EXEC为止。

被 WATCH的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC执行之前被修改了，那么整个事务都会被取消， EXEC返回nil-reply来表示事务已经失败。

这种行为叫做**乐观锁**，它是一种非常强大的锁机制。 并且因为大多数情况下，不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。