在jdk1.6之前它就是个实实在在的重量锁，性能非常低下。因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高

在jdk1.6之后对jvm中synchronized进行了优化工作，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。就是说synchronized可能不是实实在在的重量锁了，在对应的场景根据并发竞争情况进行以下转变。



![img](http://pcc.huitogo.club/69c165be9b4f92e8ab76cc706af566df)



锁升级流程

![img](http://pcc.huitogo.club/7e1834fa232f886c154586308d785aad)



#### 1. 偏向锁

大部分情况下，锁不仅仅不存在多线程竞争，而是总是由同一个线程多次获得， 为了让线程获取锁的代价更低就引入了偏向锁的概念。 怎么理解偏向锁呢？当一个线程访问加了同步锁的代码块时，会在对象头中存储当前线程的ID ，后续这个线程进入和退出这段加了同步锁的代码块时不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了



![img](http://pcc.huitogo.club/42d09c3228e7c19ee0357c20c3a4b006)



##### 1.1 偏向锁获取

1. 首先获取锁对象的Markword，判断是否处于可偏向状态，（ biased _lock=1 、且 ThreadId 为空）
2. 如果是可偏向状态，则通过CAS操作，把当前线程的ID写入到MarkWord
   1) 如果cas成功，那么markword就会变成这样。表示已经获得了锁对象的偏向锁，接着执行同步代码块
   2) 如果cas失败，说明有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向的线程，并且把它持有的锁升级为轻量级锁（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行
3. 如果是已偏向状态，需要检查markmark中存储的ThreadID是否等于当前线程的ThreadID
   a) 如果相等，不需要再次获得锁，可直接执行同步代码
   b) 如果不相等，说明当前锁偏向于其他线程，需要撤销偏向锁并升级到轻量级锁



##### 1.2 偏向锁撤销

偏向锁的撤销并不是把对象恢复到无锁可偏向状态，因为偏向锁并不存在锁释放的概念 而是在获取偏向锁的过程中，发现 cas 失败也就是存在线程竞争时，直接把被偏向的锁对象升级到被加了轻量级锁的状态。

对原持有偏向锁的线程进行撤销时，有两种情况：
1. 原获得偏向锁的线程如果已经退出了临界区，也就是同步代码块执行完了，那么这个时候会把对象头设置成无锁状态并且争抢锁的线程可以基于 CAS 重新偏向但前线程
2. 如果原获得偏向锁的线程的同步代码块还没执行完，处于临界区之内， 这个时候 会把原获得偏向锁的线程升级为轻量级锁后继续执行同步代码块



在我们的应用开发中，绝大部分情况下一定会存在2个以上的线程竞争，那么如果开启偏向锁，反而会提升获取锁的资源消耗。所以可以通过 jvm 参数-UseBiasedLocking来设置开启或关闭偏向锁



#### 2. 轻量锁

在偏向锁失效后（有竞争的情况），会转向轻量锁，使用CAS操作去代替互斥量，它和偏向锁的本质都是想减少传统的重量级锁使用操作系统互斥量产生的性能消耗。



![img](http://pcc.huitogo.club/ab7bee8c1b0cea774e909117e396cc28)



##### 2.1 加锁

锁升级为轻量级锁之后，对象的Markword 也会进行相应的变化。

升级为轻量级锁的过程：

1. 线程在自己的栈桢中创建锁记录 LockRecord 。
2. 将锁对象的对象头中的 MarkWord 复制到线程的刚刚创建的锁记录中。
3. 将锁记录中的 Owner 指针指向锁对象。
4. 将锁对象的对象头的 MarkWord 替换为指向锁记录的指针。



##### 2.2 解锁

轻量级锁的锁释放逻辑其实就是获得锁的逆向逻辑，通过CAS 操作把线程栈帧中的 LockRecord 替换回到锁对象的MarkWord中，如果成功表示没有竞争。如果失败，表示当前锁存在竞争，那么轻量级锁就会膨胀成为重量级锁。



#### 3. 自旋锁

轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。

互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。

**所以一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的**。于是虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。**为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。**

自旋锁在 JDK1.6之前其实就已经引入了，不过是默认关闭的，需要通过--XX:+UseSpinning参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。

另外,在 JDK1.6中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。



#### 4. 锁清除

锁清除指的是就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。



#### 5. 锁粗化

使用synchronized关键字的时候我们会尽可能的只在对共享变量的操作中使用它，可以使用同步的操作量尽可能的小，减少同步的操作时间。

但是在同步操作之间比较频繁的情况下，就是出了一段同步代码又进入了另一段同步代码（又得重新挂起自身线程去申请锁），建议进行锁粗化操作。