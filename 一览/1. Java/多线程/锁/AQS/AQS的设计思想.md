**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中**。



AQS提供了两种方式来获取资源，一种是独占模式，一种是共享模式。

使用AQS框架需要定义一个类继承AbstractQueuedSynchronizer类，重写其中的方法，主要实现的是对共享资源state的获取和释放方式，至于具体线程等待队列的维护（如获取资源失败入队，唤醒出队等）已经由AQS封装好的。

- 对于独占模式，需要重写tryAcquire(arg) ，tryRelease(int arg)方法。
- 对于共享模式，需要重写tryAcquireShared(arg) ，tryReleaseShared(int arg)方法。

事实上AQS中除了这些方法外其他方法都是final的，无法被其他类使用。



**总结**

1. **AQS的实质是两种队列**，一条双向同步队列，一条或多条单向条件队列

   1）线程在获取不到lock之后会进入同步队列，找一个安全的位置（前置节点的waitstatus是SIGNAL，保证前置节点结束后会唤醒后置节点）将自己阻塞，等待唤醒后去获取锁。

   2）线程在被await后会放弃lock并进入等待队列，在清理一次CANCELLED节点后将自己阻塞，等待唤醒后加入同步队列去获取锁（会对中断做出回应）。

2. 只有同步队列中的第二个节点才有资格去获取锁。

3. 公平锁和非公平锁的区别就是非公平锁每个线程都可以先直接尝试修改state的值（获取锁），然后在失败的情况下才会加入同步队列等待；公平锁就是要老老实实的在同步队列中排队。

4. AQS只是一个框架，提供了很多方法给其他类重写从而实现不同的功能，如ReentrantLock实现了独占锁，Semaphore和CountDownLatch实现了共享锁，主要重写的逻辑和方法就是获取锁和释放锁。