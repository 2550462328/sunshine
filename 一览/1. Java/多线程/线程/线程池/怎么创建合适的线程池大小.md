我们自定义线程池时，关键在于**ThreadPoolExecutor的构造**

这个构造方法对于队列时什么类型比较关键

**在使用有界队列时**：若有新任务需要执行，如果实际线程数小于corePoolSize，则优先创建线程，若大于corePoolSize，则会将任务加入队列，若队列已满，则总线程在不大于maxmumPoolSize的前提下，创建新的线程，否则执行拒绝策略，或其他自定义方式。

**在使用无界队列时**：LinkedBlockingQueue。与有界队列相比，除非资源耗尽，否则无界的任务队列不存在任务入队失败的情况，当新任务到来的时候，系统的线程数小于corePoolSize时，则新建线程执行任务。当到达corePoolSize后，就不会继续增加，若后续仍有新的任务加入，而又没有空闲的线程资源，则任务会进入队列等待，若任务处理和创建的速度相差很大，无界队列会保持快速的增长，直到系统资源耗尽。



**我们应该怎么创建线程池呢？**

首先在设置线程池线程数量的时候会遇到哪些问题？

1. 线程数量过多，首先资源方面就浪费了，另外大量线程运作的话会导致大量的线程上下文切换
2. 线程数量过少，第一响应时间肯定下降了，比较线程有限从队列中处理任务能力有限，其次就是可能会导致大量的任务堆积触发OOM。

所以，一定要选择合适的线程池数量和队列大小。



这里有个简单和适用广的公式：

**CPU 密集型任务(N+1**)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。

**I/O 密集型任务(2N)**： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。



那怎么区分CPU 密集型任务和I/O 密集型任务呢？

CPU 密集型简单理解就是利用 CPU 计算能力的任务，比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。