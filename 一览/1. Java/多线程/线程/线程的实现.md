### 1. 使用内核线程实现

内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。

这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型

![img](http://pcc.huitogo.club/31902f02e98b2420f4f248967cfbfedd)



**优点**：由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作

**缺点**：由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。



### 2. 使用用户线程实现

狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。 这种进程与用户线程之间1：N的关系称为一对多的线程模型

![img](http://pcc.huitogo.club/36a459bba3229b26fc741bbd9b10d412)



**优点**：不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的

**缺点**：使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。因而使用用户线程实现的程序一般都比较复杂。



### 3. 使用用户线程加轻量级进程混合实现

混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。

这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系

![img](http://pcc.huitogo.club/1a80f04ee280d71d1abd94a63a535598)



### 4. Java线程的实现

在JDK 1.2之前，是基于称为“绿色线程”（Green Threads）的用户线程实现的。

在JDK 1.2中，线程模型替换为基于操作系统原生线程模型来实现。因此，在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。

比如对Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。

而在Solaris平台中，由于操作系统的线程特性可以同时支持一对一（通过Bound Threads或Alternate Libthread实现）及多对多（通过LWP/Thread Based Synchronization实现）的线程模型，因此在Solaris版的JDK中也对应提供了两个平台专有的虚拟机参数：-XX：+UseLWPSynchronization（默认值）和-XX：+UseBoundThreads来明确指定虚拟机使用哪种线程模型。



这里针对Sun JDK的线程实现方式来讲

在多核操作系统上， JVM 允许在一个进程内同时并发执行多个线程。JVM 中的线程 与操作系统中的线程是相互对应的，在 JVM 线程的本地存储、缓冲区分配、同步对象、 栈、程序计数器等准备工作都完成时， JVM 会调用操作系统的接口创建一个与之对应的 原生线程；在 JVM 线程运行结束时，原生线程随之被回收。

操作系统负责调度所有线程， 并为其分配CPU时间片，在原生线程初始化完毕时，就会调用 Java 线程的 run（）方法执行 该线程；在线程结束时，会释放原生线程和 Java 线程所对应的资源。



JVM 后台运行的线程主要有以下几个

1. **虚拟机线程**（ JVM Thread)： 虚拟机线程在 JVM 到达安全点（ SafePoint ）时出现
2. **周期性任务线程**：通过定时器调度线程来实现周期性操作的执行
3. **GC 线程**： GC 线程支持 JVM 中不同的垃圾回收活动
4. **编译器线程**：编译器线程在运行时将字节码动态编译成本地平台机器码， 是JVM 跨平台的具体实现
5. **信号分发线程**：接收发送到 JVM 的信号并调用 JVM 方法