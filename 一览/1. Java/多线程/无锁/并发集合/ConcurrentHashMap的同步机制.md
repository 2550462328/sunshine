首先是读操作，从源码中可以看出来，在get操作中，根本没有使用同步机制，也没有使用unsafe方法，所以读操作是支持并发操作的。

那么写操作呢？

分析这个之前，先看看什么情况下会引起数组的扩容，扩容是通过transfer方法来进行的。而调用transfer方法的只有trePresize、helpTransfer和addCount三个方法。

这三个方法又是分别在什么情况下进行调用的呢？

1. tryPresize是在treeIfybin和putAll方法中调用，treeIfybin主要是在put添加元素完之后，判断该数组节点相关元素是不是已经超过8个的时候，如果超过则会调用这个方法来扩容数组或者把链表转为树。
2. helpTransfer是在当一个线程要对table中元素进行操作的时候，如果检测到节点的HASH值为MOVED的时候，就会调用helpTransfer方法，在helpTransfer中再调用transfer方法来帮助完成数组的扩容
3. addCount是在当对数组进行操作，使得数组中存储的元素个数发生了变化的时候会调用的方法。



**所以引起数组扩容的情况如下：**

1. 只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，同时数组的长度又小于64的时候，才会触发数组的扩容。
2. 当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容



**那么在扩容的时候，可以不可以对数组进行读写操作呢？**

事实上是可以的。当在进行数组扩容的时候，如果当前节点还没有被处理（也就是说还没有设置为fwd节点），那就可以进行设置操作。

如果该节点已经被处理了，则当前线程也会加入到扩容的操作中去。



**那么，多个线程又是如何同步处理的呢？**

1. 在ConcurrentHashMap中，同步处理主要是通过Synchronized和unsafe两种方式来完成的。
2. 在取得sizeCtl、某个位置的Node的时候，使用的都是unsafe的方法，来达到并发安全的目的。
3. 当需要在某个位置设置节点的时候，则会通过Synchronized的同步机制来锁定该位置的节点。
4. 在数组扩容的时候，则通过处理的步长和fwd节点来达到并发安全的目的，通过CAS设置hash值为MOVED。
5. 当把某个位置的节点复制到扩张后的table的时候，也通过Synchronized的同步机制来保证线程安全。