**什么是B+树？在B树的基础上到底+了什么？**

B+树是应文件系统所需而出的一种B-树的变型树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。



**一个m阶的B+树具有如下几个特征：**

- 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），**每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。**
- 所有的**叶子结点中包含了全部元素的信息**，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
- B+树查找时是从上到下查找；B-树则是从下往上查找（中序遍历）



比如一个3阶的B+树如下：

![img](http://pcc.huitogo.club/8f5229e8f1139bb0ff547a38853f8c0e)



从上图中，我们看出

- 在上面这棵树中，根节点元素8是子节点2, 5, 8的最大元素，也是叶子节点6, 8的最大元素；根节点元素15是子节点11, 15的最大元素，也是叶子节点13, 15的最大元素。
- 需要注意的是，根节点的最大元素(这里是15),也就等同于整个B+树的最大元素。以后无论插入删除多少元素，始终要保持最大元素在根节点当中。
- 至于叶子节点，由于父节点的元素都出现在子节点，因此所有叶子节点包含了全量元素信息；并且每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。



从B+树的特征看，我们知道**B+树和B-树相比最大的差异就是卫星数据的位置**：

所谓卫星数据，指的是索引元素所指向的数据记录，比如数据库中的某一行。

在B-树中，无论中间节点还是叶子节点都带有卫星数据。



![img](http://pcc.huitogo.club/c0f86a96c581a8793215e720b23f6a8a)



而在B+树当中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。



![img](http://pcc.huitogo.club/8d2b306ca692ee99e4f2ca988fec8d79)



那为什么B+树要这么设计呢？

这里我们和B-树对比着说

#### 1. 查询单个元素

比如我们在例子中3阶的B+树中查找元素3

第一次磁盘IO：



![img](http://pcc.huitogo.club/cb7fd384e3bd384286443c6c8f49440e)



第二次磁盘IO:



![img](http://pcc.huitogo.club/5d3daf70f31632d7db8176fe1076d5b7)



第三次磁盘IO：



![img](http://pcc.huitogo.club/a640bc5e51256cdedd900530cf546cf7)



可以看出从查询的方式上看和B-树是一样的，但是我们要知道

- B+ 树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素，这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时I0次数也更少。
- 其次，B+ 树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B- 树的查找性能并不稳定(最好情况是只查根节点，最坏情况是查到叶子节点)。而B+树的每一次查找都是稳定的。



#### 2. 区间查询

当我们查询一段区间元素的时候会发生什么呢？比如在上述例子中查询3~11的元素

对于B-树

自顶向下，查找到范围的下限（3）：



![img](http://pcc.huitogo.club/868168391b415938775680447325fa58)



中序遍历到元素6：



![img](http://pcc.huitogo.club/c789330fb4eeff8ba5361e4b965eb8c2)



中序遍历到元素8：



![img](http://pcc.huitogo.club/88f5838b217ba9defcc9e89e008d4fcf)



中序遍历到元素9：



![img](http://pcc.huitogo.club/82ea0892615630fa07015b564b8585bd)



中序遍历到元素11，遍历结束：



![img](http://pcc.huitogo.club/392e8256de1a94b45572022532c8efa4)



所以可以看出对于区间查询B-树的查询过程就太笨重了。



反观B+树

自顶向下，查找到范围的下限（3）：



![img](http://pcc.huitogo.club/8170e70a0875c31482c9265fe500a1ff)



通过链表指针，遍历到元素6, 8：



![img](http://pcc.huitogo.club/ce7e8690d756db985893187f2442b131)



通过链表指针，遍历到元素9, 11，遍历结束：



![img](http://pcc.huitogo.club/bb6099a8e03985307af61b791592a88f)



综上所述，相比B-树，B+树对于查询的优势：

- 单一节点存储更多的元素（这样该节点下分支变多了，树变矮胖了），使得查询的IO次数更少。
- 所有查询都要查找到叶子节点，查询性能稳定；
- 所有叶子节点形成有序链表，便于范围查询。

所以，我有什么理由不用B+树呢？



那么B树真的一无是处了吗？

也不能这么说，比如我查询一个元素，刚好是根节点或者是前几层直接就命中的节点，就会直接返回，自然效率也会高一点，反观B+树查询单个元素必须得遍历到叶子节点，这也是B+查询稳定性牺牲的一个弊端。

所以在一些查询频率比较快的，可以尽量将查询次数比较多的元素放到根节点和前几层节点上，这样**命中即返回**也是很好的。

当然了，B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。 mysql底层存储是用B+树实现的，因为内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了。

所以说**B+树是为文件系统索引而生**的不无理由，包括mysql索引就是B+树实现的。