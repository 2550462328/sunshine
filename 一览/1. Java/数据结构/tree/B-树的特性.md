**首先什么是B树，也叫B-树（中间是连字符，不是减号）？**

我们之前学过平衡二叉树，典型实现就是红黑树，B树就是平衡多叉树



**为什么发明平衡多叉树呢？**

因为我们发现平衡二叉树即使是满二叉树，它的查询搜索的遍历还是很深，因为它的特性（每个节点最多只能有左右两个分支）限制了它，所以呢，我们希望增加每个节点的分支树，让它显得矮胖矮胖的，这样没准搜索快一点。



作为一个合格的m阶**B树，必须有以下的特征**

1. 根结点至少有两个子女。
2. 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
3. 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
4. 所有的叶子结点都位于同一层。
5. 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。



**为什么做一个B树要这么麻烦？**

因为每一个B树都是矮胖矮胖的，矮瘦矮瘦人家用你干嘛？二叉树不香么？

综合以上特点我们举一个3阶的B树说明



![img](http://pcc.huitogo.club/ea9f2d7c705cadef6c542187527d51af)



其中Pn是孩子，蓝色的数值是每个节点存储的元素

当我们搜索元素n的时候，以第一个节点为例吧，n<17就去孩子P1，17<n<35去孩子P2，n>35去孩子P3，依次类推，当然命中了就直接返回。



所以我们对**B树的特性**总结一下就是

- 关键字集合分布在整颗树中；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束；
- 其搜索性能等价于在关键字全集内做一次二分查找；
- 自动层次控制；