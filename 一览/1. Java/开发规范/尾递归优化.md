**1. 什么是递归**

递归的本质是，某个方法中调用了自身。本质还是调用一个方法，只是这个方法正好是自身而已。

递归的缺点也是在自身中调用自身，于是嵌套调用（栈帧无法回收，开销巨大），有可能发生内存溢出。



**2. 什么是尾递归**

递归的本质是某个方法调用了自身，尾递归这种形式就要求：某个方法调用自身这件事，一定是该方法做的最后一件事（所以当有需要返回值的时候会是return f(n)，没有返回的话就直接是f(n)了）。



例如

正常的递归

```
1. def recsum(x): 

2.  if x == 1: 

3.   return x 

4.  else: 

5.   return x + recsum(x - 1) 
```



改造成尾递归

```
1. def tailrecsum(x, running_total=0): 

2.  if x == 0: 

3.   return running_total 

4.  else: 

5.   return tailrecsum(x - 1, running_total + x) 
```

也就是return语句只需要执行tailrecsum函数即可。



**3. 尾递归有什么优化？**

尾递归优化其实包含两方面

- 递归的形式（类似上面尾递归的形式）
- 编译器支持优化，也就是当编译器编译这段代码的时候会自动进行优化。

目前C是支持编辑器优化的，但是JAVA还是在日程上，至于为什么咱们下面再说。



那么为什么写成这样的格式然后让编译器优化下性能和安全会提高很多呢？

1. 因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了，这是一方面
2. 另一方面，正因为调用的是自身，所以需要的存储空间是一毛一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间



所以总结：为了解决递归的开销大问题，使用尾递归优化，具体分两步：

1. 你把递归调用的形式写成尾递归的形式；
2. 编译器碰到尾递归，自动按照某种特定的方式进行优化编译



**4. 为什么JAVA迟迟不做尾递归编译器优化？**

官方说法是：JAVA编写组不实现尾递归优化是觉得麻烦又没有太大的必要，就懒得实现了（原话是：在日程表上，但是非常靠后），官方的建议是不使用递归，而是使用while循环，迭代，递推